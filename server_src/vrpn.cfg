# vrpn.cfg.SAMPLE for VRPN version 07.18

################################################################################
################################################################################
# This file provides comments and examples for the vrpn.cfg file that is read
# by the vrpn_server application when it starts up. This is a generic server
# application that can start up many but maybe not all servers.
#
# This has sample lines for a vrpn.cfg file.  If you get a new device working,
# add a line for it here.  DO NOT remove lines from this file (unless
# devices are declared obsolete) - just change the actual vrpn.cfg to match
# your application.
#
# All examples in the file are preceeded by comment characters (#). To actually
# use one of these examples, remove that character from the beginning of all the
# examples that you want to use, and edit those lines to suit your environment.
################################################################################

################################################################################
# NULL Tracker. This is a "device" that reports the Identity transformation for
# each of its sensors at the specified rate. It can be used to verify connections
# are working and for other tests of VRPN. There are three arguments:
#	char	name_of_this_device[]
#	int	number_of_sensors
#	float	rate_at_which_to_report_updates

#vrpn_Tracker_NULL	Tracker0	2	2.0

################################################################################
# Flock-of-birds Tracker. Runs an Ascension Flock of Birds tracker that is
# attached to a serial port on this machine. Note that there is another driver
# (listed below) that runs the Flock when each sensor is connected to its own
# serial line. Arguments:
#   char    name_of_this_device[]
#   int	    number_of_sensors
#   char    name_of_serial_device[]
#   int	    baud_rate_of_serial_device
#   int     invert_quaternion (0 = no, 1 = yes)
#   char    useERT  (OPTIONAL; defaults to yes)
#   char[2] active_hemisphere (OPTIONAL; defaults to +z)
#
# NOTE: for useERT: use nothing, y or Y if you have an extended range
# transmitter, use N or n if not (added by David Nahon for Virtools
# VRPack/SAS Cube.
# NOTE: The "invert_quaternion" parameter was added because there was a
# conflict between the code that had been around since VRPN started and
# the Flock documentation -- it looks like most people had been using the
# Flock in the "wrong" hemisphere, which inverted the orientation relative
# to the position.  The old behavior is obtained by specifying "1".  Not
# inverting it is specified using "0".
# NOTE: active hemisphere is one of "+x", "-x", "+y", "-y", "+z", "-z"
# If "active_hemisphere" is not specified, it defaults to +z.


#vrpn_Tracker_Flock	Tracker0	4	/dev/ttyS0	115200	1

# If you have to FOB, with no Extended Range ctrler/transmitter, on Windows,
# with -x as the active hemisphere, use

#vrpn_Tracker_Flock	Tracker0	2	COM1	38400	1	N  -x

# Watch: be sure that the serial baud rate dip switches (the 3 on the left)
# of your master flock are properly set.
# You should try baud rates like 38400 before trying to go higher
# In normal adress mode - less than 14 fob units - your switch should be:
# 0 1 2 3 4 5 6 7
# 0 0 1	X X X X 0 	2400
# 0 1 0	X X X X 0	4800
# 0 1 1	X X X X 0	9600
# 1 0 0	X X X X 0	19200
# 1 0 1	X X X X 0	38400
# 1 1 0	X X X X 0	57600
# 1 1 1	X X X X 0	115200
#
# X X X X are used for coding the FOB adress, they must be set correctly,
# even if you are only using 1 unit (standalone mode)
# the settings should be (in normal adress mode):
# 3 4 5 6
# 0 0 0 1	for the first unit
# 0 0 1 0	for the second unit
# 0 0 1 1	for the third
# 0 1 0 0	for the fourth
# 0 1 0 1	for the fifth
# ...
#
############################################################################
# WATCH WATCH WATCH WATCH WATCH WATCH WATCH WATCH WATCH WATCH WATCH WATCH
###################
#
# On windows at least, it might be necessary to cut your serial cable so as
# to only have Transmit, Recieve and Ground pins. Even if CBIRDS or WINBIRDS
# are fine with a cable, it doesn't mean that this cable will please vrpn.
# This limitation should have been fixed with version 06.05.
#
###################

################################################################################
# Flock-of-birds in parallel Tracker. Runs an Ascension Flock of Birds tracker
# that has its source and each sensor plugged into its own serial port on this
# machine (perhaps through a Cyclades multi-port serial card). This mode of
# operation increases the throughput and decreases the latency of tracker reports.
# The arguments match those of the Flock-of-birds tracker from above, with the
# addition of the name of the serial ports for each of the sensors added at the
# end. Arguments (all on the same line):
#	char	name_of_this_device[]
#	int	number_of_sensors
#	char	name_of_serial_device_for_controller[]
#	int	baud_rate_of_serial_device
#	int   invert_quaternion (0 = no, 1 = yes)
#	[one for each sensor]	char	name_of_serial_device_for_sensor[]
#
# NOTE: The "invert_quaternion" parameter was added because there was a
# conflict between the code that had been around since VRPN started and
# the Flock documentation -- it looks like most people had been using the
# Flock in the "wrong" hemisphere, which inverted the orientation relative
# to the position.  The old behavior is obtained by specifying "1".  Not
# inverting it is specified using "0".

#vrpn_Tracker_Flock_Parallel	Tracker0	4	/dev/ttyC4	115200	1	/dev/ttyC0 /dev/ttyC1 /dev/ttyC2 /dev/ttyC3
#vrpn_Tracker_Flock_Parallel	Tracker0	2	COM1	115200	1	COM2 COM3

################################################################################
# Fastrak Tracker. Runs a Polhemus Fastrak tracker that is attached to a serial
# port on this machine. This driver will also run an InterSense IS600 or IS900
# tracker, but you will want to include extra initialization code (as described
# below) to set up the ultrasonic pip information, wand devices, stylus devices
# and so forth.  Arguments that go on the first line:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device
#
# It is possible to add additional commands that will be sent to the tracker
# by putting the backslash character (\) at the end of the config line. This
# will cause the following line to be read in and sent to the Fastrak during
# the reset routine. You can add additional lines by putting a slash at the
# end of each command line but the last. Each line will be sent to the Fastrak
# with a newline at the end of it. If a line starts with an asterisk (*), then
# it is treated as a line telling how long to sleep, with the integer number of
# seconds following the *.
#
# If one or more sensors on the Fastrak have a stylus button on them, use
# the "FTStylus" command after the reset command lines (if any).  There should
# be a front-slash "/" character at the end of the line before the FTStylus
# command.  The command takes two arguments: the name of the button device
# that will report the buttons and the sensor number to which the button is
# attached (the first sensor is sensor 0).
#
# Commands to add Joysticks (2 buttons) or Wands (5 buttons and 2 analogs) to
# the various sensors on the Isense900 are done by adding Stylus and
# Wand command lines after the reset command lines.  Each of these lines
# takes two arguments: the name of the button (for Stylus) or button and
# analog (for Wand) servers, and the sensor number (starting from 0).  The
# Wand line takes eight additional parameters, which specify the scaling
# and clipping behavior of the two directions on the analog joystick.  Each
# set of for is the min, lowzero, hizero, and max values: these are mapped
# to -1, 0,0, and 1 (all values between lowzero and hizero are mapped to 0).
# Start with these at -1,0,0,1 and use the 'printcereal' program or some other
# method to read them and see what the range of acheivable values is.  Then,
# set them to slightly conservative values so that the whole range is covered
# and the analogs will report zero when the joystick is centered. The
# presence of these lines is indicated by placing them after any additional
# reset command lines, by ending the line preceding them with the front slash
# "/" character.
#
# Remember that the "remote" button object is not the same as the the tracking
# device, so be sure to use a remote button object that connects to the button
# rather than the tracker.  The button device name is defined on the stylus or
# wand line in the config file, and should not be the same as the tracker.  In
# the case described by the example configuration below, if the name of the
# machine running the server is "myis900server" you would connect to the tracker
# as "Isense900@myis900server" and to the buttons on the stylus as
# "Stylus0@myis900server":
#
# Note that this frontslash and backslash-notation can only be used for the
# Fastrak/Isense tracker, not to extend the line for any other type of device
# listed in this configuration file.

# Vanilla Fastrak on on a Unix box
#vrpn_Tracker_Fastrak	Fastrak0	/dev/ttyS0	19200

# Fastrak with a stylus on sensor zero on a Windows box
#vrpn_Tracker_Fastrak	Tracker0	COM1	115200 /
#FTStylus Stylus0 0

# IS600 and its pip settings
#vrpn_Tracker_Fastrak	Isense600	/dev/ttyS0	19200 \
#MCc\
#*5\
#MCM1,1,0.0900,0.0000,-0.2210,0.00,0.00,-1.00,89\
#MCM1,2,-0.0566,0.0000,-0.2210,0.00,0.00,-1.00,87\
#MCM2,1,0.0900,0.0000,-0.2210,0.00,0.00,-1.00,66\
#MCM2,2,-0.0566,0.0000,-0.2210,0.00,0.00,-1.00,71\
#MCM3,1,0.1237,-0.0762,-0.0424,0.00,0.00,-1.00,82\
#MCM3,2,0.1237,0.0762,-0.0424,0.00,0.00,-1.00,77\
#MCe\
#*10

# IS900 with a wand on the first sensor and a stylus on the third:
#vrpn_Tracker_Fastrak	Isense900	COM1	115200 /
#Wand		Wand0		0	-1.0 0.0 0.0 1.0  -1.0 0.0 0.0 1.0 /
#Stylus	Stylus0	2

################################################################################
# Liberty Tracker. Runs a Polhemus Liberty tracker that is attached to a serial
# port or USB port on this machine.  Arguments that go on the first line
#	char	name_of_this_device[]
#	char	name_of_serial_or_usb_device[]
#	int	baud_rate_of_serial_device (not used when the device is USB)
#	int	number_of_chars_in_whoami_response (optional)
#
# It is possible to add additional commands that will be sent to the tracker
# by putting the backslash character (\) at the end of the config line. This
# will cause the following line to be read in and sent to the Liberty during
# the reset routine. You can add additional lines by putting a slash at the
# end of each command line but the last. Each line will be sent to the Fastrak
# with a newline at the end of it. If a line starts with an asterisk (*), then
# it is treated as a line telling how long to sleep, with the integer number of
# seconds following the *.
#
# If one or more sensors on the Liberty have a stylus button on them, use
# the "Stylus" command after the reset command lines (if any).  There should
# be a front-slash "/" character at the end of the line before the Stylus
# command.  The command takes two arguments: the name of the button device
# that will report the buttons and the sensor number to which the button is
# attached (the first sensor is sensor 0).
#

# -------------------------------------------
# Example when Liberty is attached via USB
# The BAUD Rate is needed, although it is not used

#vrpn_Tracker_Liberty	Liberty	/dev/usb/ttyUSB0	115200

#--------------------------------------------
# Example when Liberty is attached via Serial

#vrpn_Tracker_Liberty   Liberty /dev/ttyS0        115200

#--------------------------------------------
# Example when Liberty is attached via Serial with a non-standard whoami length

#vrpn_Tracker_Liberty   Liberty /dev/ttyS0        115200	247

#--------------------------------------------
# Liberty attached via Serial with styluses on sensors zero and three
#vrpn_Tracker_Liberty	Tracker0	/dev/ttyS0	115200 /
#Stylus Stylus0 0 /
#Stylus Stylus1 3

################################################################################
# InterSense tracker using the Intersense-provided library to communicate
# with the tracker.  This device type is not compiled by default, since it uses
# a proprietary library.  However, you can get it to compile by defining
# VRPN_INCLUDE_INTERSENSE when compiling.  Note that the Fastrak driver will
# run IS-600 and IS-900 trackers without the proprietary library, so you might
# try that as well.
#
# You can include extra initialization code (as described
# below) to set up the ultrasonic pip information, wand devices, stylus devices
# and so forth.  Arguments that go on the first line:
#       char    name_of_this_device[]
#       char    name_of_serial_device[] - this can be COM1-4 or AUTO
#                                     AUTO will automatically find USB and
#                                     serial trackers. Use COM1-4 only if you
#                                     have more than one serial tracker.
#                                     You should use COM1-4 on unix as well,
#                                     as these just tell the isense library
#                                     to look in serial port 1-4.
#                                     I guess you can't have >1 USB trackers.
#     char "IS900time"		- use the IS900 timestamps (optional)
#     char "ResetAtStartup"	- resets all boresight and heading, on intertrax, 
#			          equivalent to push the reset button
#
# It is possible to add additional commands that will be sent to the tracker
# by putting the backslash character (\) at the end of the config line. This
# will cause the following line to be read in and sent to the InterSense during
# the reset routine. You can add additional lines by putting a slash at the
# end of each command line but the last. Each line will be sent to the InterSense
# with a newline at the end of it. If a line starts with an asterisk (*), then
# it is treated as a line telling how long to sleep, with the integer number of
# seconds following the *.
#
# Commands to add Joysticks (2 buttons) or Wands (5 buttons and 2 analogs) to
# the various sensors on the Isense900 are done by adding Stylus and
# Wand command lines after the reset command lines.  Each of these lines
# takes two arguments: the name of the button (for Stylus) or button and
# analog (for Wand) servers, and the sensor number (starting from 0).  The
# Wand line takes eight additional parameters, which specify the scaling
# and clipping behavior of the two directions on the analog joystick. Each
# set of for is the min, lowzero, hizero, and max values: these are mapped
# to -1, 0,0, and 1 (all values between lowzero and hizero are mapped to 0).
# Start with these at -1,0,0,1 and use the 'printcereal' program or some other
# method to read them and see what the range of acheivable values is. Then,
# set them to slightly conservative values so that the whole range is covered
# and the analogs will report zero when the joystick is centered. The
# presence of these lines is indicated by placing them after any additional
# reset command lines, by ending the line preceding them with the front slash
# "/" character.
#
# Remember that the "remote" button object is not the same as the the tracking
# device, so be sure to use a remote button object that connects to the button
# rather than the tracker.  The button device name is defined on the stylus or
# wand line in the config file, and should not be the same as the tracker. In
# the case described by the example configuration below, if the name of the
# machine running the server is "myis900server" you would connect to the tracker
# as "Isense900@myis900server" and to the buttons on the stylus as
# "Stylus0@myis900server":
#
# Note that this frontslash and backslash-notation can only be used for the
# Fastrak and InterSense tracker, not to extend the line for any other
# type of device
# listed in this configuration file.
#
# Note that this driver expects the device to be set to output centimeters, and will convert 
# the positions to meters. It is recommanded to permanently set the units in the eeprom of your device.
# If this is not possible, you should add in this file the "u" reset command so as to have vrpn
# tell your device to use centimeters
#
#Vanilla InterSense
#vrpn_Tracker_InterSense Tracker0 AUTO IS900time

# Vanilla InterSense using IS900 timing, with wand in port B (and possibly head tracker in port A)
#vrpn_Tracker_InterSense Tracker0 AUTO IS900time /
#Wand            Wand0           1       -1.0 0.0 0.0 1.0  -1.0 0.0 0.0 1.0

# IS600 and its pip settings
#vrpn_Tracker_InterSense        Isense600       COM1 \
#MCc\
#*5\
#MCM1,1,0.0900,0.0000,-0.2210,0.00,0.00,-1.00,89\
#MCM1,2,-0.0566,0.0000,-0.2210,0.00,0.00,-1.00,87\
#MCM2,1,0.0900,0.0000,-0.2210,0.00,0.00,-1.00,66\
#MCM2,2,-0.0566,0.0000,-0.2210,0.00,0.00,-1.00,71\
#MCM3,1,0.1237,-0.0762,-0.0424,0.00,0.00,-1.00,82\
#MCM3,2,0.1237,0.0762,-0.0424,0.00,0.00,-1.00,77\
#MCe\
#*10

# IS900 with a wand on the first sensor and a stylus on the third:
#vrpn_Tracker_InterSense        Isense900       COM1 /
#Wand           Wand0           0       -1.0 0.0 0.0 1.0  -1.0 0.0 0.0 1.0 /
#Stylus Stylus0 2

# Intertrax2 on USB, With automatic reset at startup
#vrpn_Tracker_InterSense        Tracker0       AUTO  ResetAtStartup

################################################################################
# Dynasight Tracker. Runs an Origin System's DynaSight tracker connected to a
# serial port on this machine. arguments:
#	char	name_of_this_device[]
#	int	number_of_sensors
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device

#vrpn_Tracker_Dyna	Tracker0	1	/dev/ttyS0	19200

#vrpn_Tracker_Dyna	Tracker0	1	COM1		19200

################################################################################
# Crossbow Tracker. Runs a Crossbow Technology RGA300-series tracker that is
# attached to a serial port on this machine. There are four arguments:
#       char    name_of_this_device[]
#       char    name_of_serial_device[]
#       int             baud_rate_of_serial_device (should be 38400)
#       float   linear_acceleration_sensitivity (Gs; default is 2.0)
#       float   angular_rate_sensitivity (degrees per second; default is 100)

#vrpn_Tracker_Crossbow  Tracker0        COM1:   38400   2.0     100

###############################################################################
# 3d Microscribe is a mechanical tracker the nesseccary params are
# name  port baudrate
# additional params are offsetx offsety offsetz scale
# offsets are in meters.  Scale is an abomination in VRPN; all
# trackers report in meters.
#

#vrpn_3DMicroscribe Microscribe COM1 19200 0.3 -0.1 -0.2 1

################################################################################
# 5DT glove with 16 sensors.  This driver reports the 16 channels as analog
# devices.  If you want to treat them as buttons, then also add the entry
# for the vrpn_Button_5DT_Server below, connecting it to the output of this
# server.
#
# This server does not work with the previous version of the glove.
#
#  arguments:
#       char    name_of_this_device[]
#       char    name_of_serial_device[]
#       int     baud_rate_of_serial_device

#vrpn_5dt16    glove_5dt16     COM1    19200

################################################################################
#
# Use the 5dtglove16 as button device.  Use in conjunction with the vrpn_5dt16
# device above to turn the analog reports into button press/release when the
# sensors cross the threshold.
#
# arguments:
#       char name_of_this_device[]
#       char name_of_the_glove device[]
#       double threshold_toggle_point_between_pressed_and_unpressed[16]

#vrpn_Button_5DT_Server glove_5dt_button glove_5dt16 1794 2171 2110 2610 1707 2673 2459 1493 3029 2301 1936 3007 2302 1635 0 0

################################################################################
# AnalogFly Tracker. This is a tracker that is intended to be used on top of
# a joystick or motion tracker of some kind to turn it into a moving or flying
# device. It could be used on top of any analog device, in fact.
#   This device basically takes in analog signals and puts out transformation
# matrices. It should supercede the JoyFly tracker, since it is more general.
#   There are two kinds of JoyFly's: absolute ones and differential ones.  For
# absolute ones, the analog value is mapped directly to position or orientation
# on each axis.  For differential ones, the values are used to create a
# "change" matrix that is applied once per interval, accumulating changes as
# it goes; this enables the user to "fly" along by holding a joystick forward,
# for example.
#   One analog channel is associated with each axis (X, Y, Z) and rotation about
# each axis (RX, RY, RZ). For each axis, the value is converted to a position
# (meters) or speed (meters/second) for absolute trackers; or into an
# orientation (revolutions) or angular velocity (revolutions/second) by first
# subtracting an offset, then thresholding it to see if it is far enough from
# zero, then (if it is) scaling it and taking it to a power (to allow nonlinear
# speedup as the stick is pushed far from center).
#   A button can be associated with a reset function, which will take the
# device back to center (identity transformation). The device will also recenter
# when the first connection is made to the server it is running on. (Centering
# has no effect on absolute AnalogFlys).
#   A button can be associated with a clutch function, which will mean that
# the device will not move unless the clutch is pressed, so you can use it
# like a mouse and continue to move by pulling to the right with the button
# down and then to the left with the button up.  For differential analogflys,
# clutching makes the tracker not move unless the button is pressed.  For
# absolute ones, it only moves when the button is pressed and the mouse is
# moving; it offsets to enable long-range motions in a finite tracking area,
# as with a mouse.
#   Any axis or the reset button can be disabled by setting the name of its
# associated device to the string "NULL".
#   Note that you could have multiple of these devices running simultaneously,
# each with a different name and interaction metaphor. The user could then
# connect to their favorite one. Arguments:
#	char  name_of_this_device[]
#	float update_rate_to_send_tracker_reports
#	char  type[] = "absolute" or "differential"
#	[six lines follow, one for X Y Z RX RY RZ, each with:
#		char	axis_name[]			(X Y Z RX RY RZ in that order)
#		char	name_of_analog_device[]		(start with * for local)
#		int	channel_of_analog_device
#		float offset
#		float	threshold
#		float	scale
#		float	power
#	]
#	[New line to describe reset button, with:
#		char	"RESET"
#		char	name_of_button_device[]		(start with * for local)
#		int	which_button_to_use
#	]
#	[New line to describe clutch button, with:
#		char	"CLUTCH"
#		char	name_of_button_device[]		(start with * for local)
#		int	which_button_to_use
#	]

#vrpn_Tracker_AnalogFly Tracker0 60.0 absolute
#X  *Mouse0 0 0.5 0.0 2.0 1.0
#Y  *Mouse0 1 0.5 0.0 2.0 1.0
#Z  NULL 2 0.0 0.0 1.0 1.0
#RX NULL 3 0.0 0.0 1.0 1.0
#RY NULL 4 0.0 0.0 1.0 1.0
#RZ NULL 5 0.0 0.0 1.0 1.0
#RESET NULL 0
#CLUTCH *Mouse0 0

#vrpn_Tracker_AnalogFly	Tracker0	60.0	absolute
#X	*CerealBox0	4	0.0	0.021	1.0	1.0
#Y	*CerealBox0	5	0.0	0.021	1.0	1.0
#Z	*CerealBox0	6	0.0	0.021	3.0	1.0
#RX	*CerealBox0	0	0.0	0.021	1.0	1.0
#RY	*CerealBox0	1	0.0	0.021	1.0	1.0
#RZ	*CerealBox0	2	0.0	0.021	3.0	1.0
#RESET	*CerealBox	3
#CLUTCH	NULL 0

#vrpn_Tracker_AnalogFly	Tracker0	60.0	differential
#X	*Magellan0	0	0.0	0.0	2.0	1.0
#Y	*Magellan0	1	0.0	0.0	2.0	1.0
#Z	*Magellan0	2	0.0	0.0	2.0	1.0
#RX	*Magellan0	3	0.0	0.0	2.0	1.0
#RY	*Magellan0	4	0.0	0.0	2.0	1.0
#RZ	*Magellan0	5	0.0	0.0	2.0	1.0
#RESET	NULL	0
#CLUTCH	NULL 0

#vrpn_Tracker_AnalogFly	Tracker0	60.0	absolute
#X	NULL		0	0.0	0.0	1.0	1.0
#Y	NULL		0	0.0	0.0	1.0	1.0
#Z	NULL		0	0.0	0.0	1.0	1.0
#RX	*Radamec0	1	0.0	0.0	-0.0027777777	1.0
#RY	NULL		0	0.0	0.0	1.0	1.0
#RZ	*Radamec0	0	0.0	0.0	0.0027777777	1.0
#RESET	NULL	0
#CLUTCH	NULL 0

#vrpn_Tracker_AnalogFly	Tracker0	60.0	absolute
#X	*Joystick0	0	0.0	0.0	1.0	1.0
#Y	*Joystick0	1	0.0	0.0	-1.0	1.0
#Z	*Joystick0	6	0.0	0.0	1.0	1.0
#RX	NULL		3	0.0	0.0	1.0	1.0
#RY	NULL		4	0.0	0.0	1.0	1.0
#RZ	*Joystick0	5	0.0	0.0	0.5	1.0
#RESET	NULL	0
#CLUTCH	NULL 0

# Using a joystick to emulate a Phantom for the
# nanoManipulator, the throttle maps to Z.
#vrpn_Tracker_AnalogFly	Phantom	60.0	absolute
#X	*Phantom	0	0.0	0.0	0.125	1.0
#Y	*Phantom	1	0.0	0.0  -0.125	1.0
#Z	*Phantom	6	0.0	0.0	0.25	1.0
#RX	NULL		3	0.0	0.0	1.0	1.0
#RY	NULL		4	0.0	0.0	1.0	1.0
#RZ	*Phantom	5	0.0	0.0	0.06	1.0
#RESET	NULL	0
#CLUTCH	NULL 0

# For DTU/MIC optical nanoHand stage motion, moving over full 300 micron range
# of motion, using the Logitech joystick for the analog
# server and the tracker_to_poser program.
#vrpn_Tracker_AnalogFly	Tracker0	60.0	absolute
#X	*Joystick0	0	-0.03	0.0	2.53	1.0
#Y	*Joystick0	1	-0.04	0.0	2.53	1.0
#Z	*Joystick0	6	-0.10	0.0	-1.75	1.0
#RX	NULL		3	0.0	0.0	1.0	1.0
#RY	NULL		4	0.0	0.0	1.0	1.0
#RZ	*Joystick0	5	0.0	0.0	0.5	1.0
#RESET	NULL	0
#CLUTCH	NULL 0

# To drive a Tektronix 4662 full range (Z, RZ ignored)
#vrpn_Tracker_AnalogFly	Tracker0	60.0	absolute
#X	*Joystick0	0	-1.0	0.0	0.19	1.0
#Y	*Joystick0	1	1.0	0.0	-0.13	1.0
#Z	*Joystick0	6	0.0	0.0	1.0	1.0
#RX	NULL		3	0.0	0.0	1.0	1.0
#RY	NULL		4	0.0	0.0	1.0	1.0
#RZ	*Joystick0	5	0.0	0.0	0.5	1.0
#RESET	NULL	0
#CLUTCH	NULL 0

# For UNC Mad City Labs stage motion, moving over full 100 micron range
# of motion, using the Microsoft FF joystick for the analog
# server and the tracker_to_poser program.
#vrpn_Tracker_AnalogFly	Tracker0	60.0	absolute
#X	*Joystick0	0	-1	0.0	50	1.0
#Y	*Joystick0	1	-1	0.0	50	1.0
#Z	*Joystick0	6	-1	0.0	50	1.0
#RX	NULL		3	0.0	0.0	1.0	1.0
#RY	NULL		4	0.0	0.0	1.0	1.0
#RZ	*Joystick0	5	0.0	0.0	0.5	1.0
#RESET	NULL	0
#CLUTCH	NULL 0

# For Artemis or Hercules (mad-city-labs) stages
# Maps 0-10 from the voltage into the range 0-100 microns.
#vrpn_Tracker_AnalogFly	StageTracker	60.0	absolute
#X	*MCLXYZIN	4	0	0.0	10	1.0
#Y	*MCLXYZIN	5	0	0.0	10	1.0
#Z	*MCLXYZIN	6	0	0.0	10	1.0
#RX	NULL		3	0.0	0.0	1.0	1.0
#RY	NULL		4	0.0	0.0	1.0	1.0
#RZ	NULL		5	0.0	0.0	1.0	1.0
#RESET	NULL	0
#CLUTCH	NULL 0

################################################################################
# XXX This device is superceded by the more-general vrpn_Tracker_AnalogFly.
# JoyFly Tracker. A vrpn_Tracker that translates the vrpn_Joystick into
# Walkthrough- convention tracker reports. This is part of a two-part setup
# that allows you to use a joystick as a flying device. First, a joystick
# device has to be created (named joybox in our example) that will produce
# the analog inputs that the JoyFly tracker uses to determine the transformation.
# Then, the JoyFly device needs to be started and will listen to the device
# and produce tracker reports. If these are both run on the same server, then
# the JoyFly needs to use the "server" connection to hear from the Joystick
# device, which is indicated by placing a '*' in front of the name of the
# joystick device that it is to use. If the joystick device is remote from
# this server, then the full name of it should be used (joystick@foo.cs.unc.edu).
# XXX This device is superceded by the more-general vrpn_Tracker_AnalogFly
# Arguments:
#	char	name_of_this_device[]
#	char	source_joystick_name[]  (Start with * for one sharing a connection)
#	char	joystick_configuration_file_name[]

#vrpn_JoyFly walk-joybox *joybox vrpn_Joyfly.cfg

################################################################################
# ButtonFly Tracker. This is a tracker that is intended to be used on top of
# a Global Haptics Orb or other buttond device to turn it into a moving or
# flying device.  It basically takes in button signals and puts out
# transformation matrices.
#   There are two kinds of Buttons: absolute ones and differential ones.  For
# absolute ones, pressing it causes the position or orientation associated with
# it to be stored directly into the transformation.  This enables the user to
# "teleport" to given locations by pressing buttons.  For differential ones,
# the position or orientation are treated as deltas and are used to create a
# "change" matrix that is applied once per interval, accumulating changes as
# it goes; this enables the user to "fly" along by holding a button down,
# for example.
#   Each button is associated with either a position (meters) or speed
# (meters/second) for absolute buttons; or an orientation (revolutions)
# or angular velocity (revolutions/second).
#   An analog channel can be associated with a scale function that scales the
# velocity or angular velocity terms uniformly.  The entry specifies an
# offset to be applied to the analog channel, a scale to be applied to it,
# and a power to which the result should be taken; the end result is used
# to scale all velocity or angular velocity terms.  This channel has no
# effect on the effects of absolute buttons.
#   The device will recenter (set itself to the identity transform) when the
# first connection is made to the server it is running on.
#   Note that you could have multiple of these devices running simultaneously,
# each with a different name and interaction metaphor. The user could then
# connect to their favorite one. Arguments:
#	char  name_of_this_device[]
#	float update_rate_to_send_tracker_reports
#	[one or more lines follow, each of one of two types
#	    (1)	char	[] = "absolute"
#		char	name_of_button_device[] (start with * for local)
#		int	which_button_on_device
#		float	X_to_translate_to
#		float	Y_to_translate_to
#		float	Z_to_translate_to
#		float	rotation_about_X
#		float	rotation_about_Y
#		float	rotation_about_Z
#	    (2)	char	[] = "differential"
#		char	name_of_button_device[] (start with * for local)
#		int	which_button_on_device
#		float	X_translation_meters_per_second
#		float	Y_translation_meters_per_second
#		float	Z_translation_meters_per_second
#		float	spin_about_X_revolutions_per_second
#		float	spin_about_Y_revolutions_per_second
#		float	spin_about_Z_revolutions_per_second
#	]
#	[An optional line describing an analog to scale the velocity
#		char	[] = "vel_scale"
#		char	name_of_button_device[] (start with * for local)
#		int	which_button_on_device
#		float	offset
#		float	scale
#		float	power
#	]
#	[An optional line describing an analog to scale the rotation
#		char	[] = "rot_scale"
#		char	name_of_button_device[] (start with * for local)
#		int	which_button_on_device
#		float	offset
#		float	scale
#		float	power
#	]
#	[one more line, consisting of the word "end"]
#   Note that the same button can cause more than one action to take place,
# and the same analog can cause scaling of both the velocity and rotation.

# This example for a Global Haptics Orb pushes the transformation away
# from the button that is pressed
# for all of the standard buttons.  It rotates around the Y axis when the
# rocker switch is rocked up and down.  It resets to the origin when one
# of the pushbuttons is pressed.  Both the velocity and angular velocity
# are controlled by the thumbwheel.

#vrpn_Tracker_ButtonFly	Tracker0	60.0
#differential	*Orb0	0	0 1 0	0 0 0
#differential	*Orb0	1	0.707 0.707 0	0 0 0
#differential	*Orb0	2	1 0 0	0 0 0
#differential	*Orb0	3	0.707 -0.707 0	0 0 0
#differential	*Orb0	4	0 -1 0	0 0 0
#differential	*Orb0	5	-0.707 -0.707 0	0 0 0
#differential	*Orb0	6	-1 0 0	0 0 0
#differential	*Orb0	7	-0.707 0.707 0	0 0 0
#differential	*Orb0	8	0 0.707 -0.707	0 0 0
#differential	*Orb0	9	0.577 0.577 -0.577	0 0 0
#differential	*Orb0	10	0.707 0 -0.707	0 0 0
#differential	*Orb0	11	0.577 -0.577 -0.577	0 0 0
#differential	*Orb0	12	0 -0.707 -0.707	0 0 0
#differential	*Orb0	13	-0.577 -0.577 -0.577	0 0 0
#differential	*Orb0	14	-0.707 0 -0.707	0 0 0
#differential	*Orb0	15	-0.577 0.577 -0.577	0 0 0
#differential	*Orb0	16	0 0.707 0.707	0 0 0
#differential	*Orb0	17	0.577 0.577 0.577	0 0 0
#differential	*Orb0	18	0.707 0 0.707	0 0 0
#differential	*Orb0	19	0.577 -0.577 0.577	0 0 0
#differential	*Orb0	20	0 -0.707 0.707	0 0 0
#differential	*Orb0	21	-0.577 -0.577 0.577	0 0 0
#differential	*Orb0	22	-0.707 0 0.707	0 0 0
#differential	*Orb0	23	-0.577 0.577 0.577	0 0 0
#differential	*Orb0	24	0 0 -1	0 0 0
#differential	*Orb0	25	0 0 1	0 0 0
#differential	*Orb0	28	0 0 0	0 -0.1 0
#differential	*Orb0	29	0 0 0	0 0.1 0
#absolute	*Orb0	27	0 0 0	0 0 0
#vel_scale	*Orb0	0	-1.0 0.5 1.0
#rot_scale	*Orb0	0	-1.0 0.5 1.0
#end

################################################################################
# 3Space Tracker. Runs a Polhemus 3Space (not Fastrak) tracker that is attached
# to a serial port on this machine.  Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device

#vrpn_Tracker_3Space	Tracker0	/dev/ttyS0	19200

################################################################################
# Logitech 3DMouse tracker attached to a serial port on this machine.
#  Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device
#	int	filtering_count (this parameter is optional)

#vrpn_Tracker_3DMouse	Tracker0	/dev/ttyS0	19200

################################################################################
#  NDI Polaris Spectra or Vectra, attached to a serial or USB port
# This server works with the NDI Polaris Spectra and Polaris Vectra
# trackers.  It doesn't work with the Optitrak or Aurora.  It only
# handles rigid bodies made from passive sphere markers, and does
# not yet support active led markers nor single "stray" passive 
# spheres.
#
# Each vrpn "sensor" is a single rigid body (or "tool" in NDI
# terminology), which consists of 3 or more passive spheres in a 
# particular geometric arrangement. In order to define a custom
# rigid body (one that didn't come from NDI), you must use the NDI
# Architect software. That software produces .rom files for each 
# rigid body. This vrpn tracker class will load those files during 
# initialization.
#
# Before configuring the vrpn server here, you should first run
# the NDI software to track the rigid bodies using the NDI's 
# interactive GUI. Only after you have configured and tested the
# tracker and rigid bodies to your satisfaction, should you try
# this vrpn server. 
#
# This currently only handles an IR strobe rate of 60Hz, not 
# 20Hz or 30Hz.
#
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	    number of sensors (i.e. num of rigid bodies)  
#
#   char    rigidBody 0's .rom filename
#   char    rigidBody 1's .rom filename
#   char    rigidBody 2's ...

# vrpn_Tracker_NDI_Polaris Tracker0 COM1 2 
# hello.rom 
# ../world.rom

################################################################################
# Non-tracker devices. Lines are provided here for the various non-tracker servers
# that can be started.

################################################################################
# Example Dial server. This is a "device" that reports constant rotations for
# each of its dials at the specified rate. It can be used to verify connections
# are working and for other tests of VRPN. There are four arguments:
#	char	name_of_this_device[]
#	int	number_of_dials
#	float	rate_at_which_the_dials_spin		(revolutions/second)
#	float	rate_at_which_to_report_updates	(udpates/second)

#vrpn_Dial_Example	Dial0	2	2.0	10.0

################################################################################
# CerealBox dial/button/analog. Runs a BG Systems CerealBox device that attaches
# to a serial port on this machine. As of VRPN version 04.07, 19200 is the
# only supported baud rate. The driver has been tested on an LV824-F-8e device.
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device
#	int	number_of_buttons_to_read (starting from 0)
#	int	number_of_analogs_to_read
#	int	number_of_encoders_to_read

#vrpn_CerealBox	Cereal0	/dev/cua0	19200	8 8 8

################################################################################
# Magellan button/analog. Runs a Logitech Magellan device that attaches
# to a serial port on this machine. As of VRPN version 04.12, 9600 is the
# only supported baud rate.
#
# Note that if you want to use the Magellan as a tracking device, you will
# need to run a vrpn_Tracker_AnalogFly device that listens to its analog
# outputs and converts them into tracker reports
#
# John Stone added support for the SpaceBalls in version 06.03, an example
# startup is shown below.
#
# Julien Brisset discovered how to make this work with a slightly older version
# of the Magellan.  If the example Magellan line doesn't work, add 'altreset' to
# the line to use the alternative reset string for the device.
#
# NOTE: You should NOT run the driver that comes with the Magellan, since the
# VRPN driver opens the serial port and communicates with the device directly.
# If the Magellan driver from the manufacturer is running, then VRPN will not
# be able to open the port.
#
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device
#	char	"altreset"   {Optional, for older Magellans}

#vrpn_Magellan	Magellan0	COM1	9600
#vrpn_Magellan	Magellan0	/dev/ttyS0	9600	altreset
#vrpn_Spaceball	Spaceball0	/dev/ttyS0	9600

################################################################################
# NRL Immersion Box dial/button/analog. Runs a Immersion Interface Box device
# attached to a serial port. As of March 28, 2000 code to read the analog and
# angle encoders has not been implemented.  Also, baud rate on many SGI's is
# limited to 38400, but I have run the ibox at 115200 on PCs.
#       char    name_of_this_device[]
#       char    name_of_serial_device[]
#       int     baud_rate_of_serial_device
#       int     number_of_buttons_to_read (i.e. 4 ==> 0,1,2,3)
#       int     number_of_analogs_to_read
#       int     number_of_encoders_to_read

#vrpn_ImmersionBox      ibox    /dev/ttyd2      38400   4 0 0
#vrpn_ImmersionBox      ibox    com1            115200  4 0 0

################################################################################
# Wands button/analog, driver from Brown University. Runs a Wanda device
# attached to a serial port.
#
# Arguments:
#       char    name_of_this_device[]
#       char    name_of_serial_port_to_use[]
#       int     baud_rate_of_serial_device
#	  float   minimum_update_rate

#vrpn_Wanda      Wanda    /dev/ttyd2      1200   60.0
#vrpn_Wanda      Wanda    COM2      1200   60.0

################################################################################
# Radamec Serial Position Interface analog. Camera tracker that attaches
# to a serial port on this machine. Note that for normal operation, 38400 is the
# only supported baud rate.
#
# Note that if you want to use the Radamec SPI as a tracking device, you will
# need to run a vrpn_Tracker_AnalogFly device (of the absolute variety)
# that listens to its analog outputs and converts them into tracker reports.
#
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_port[]
#	int	baud_rate_of_serial_port

#vrpn_Radamec_SPI	Analog0	/dev/ttyS16	38400

################################################################################
# Zaber linear positioning element analog that attaches
# to a serial port on this machine.
#
# Note that if you want to use the Zaber as a tracking device, you will
# need to run a vrpn_Tracker_AnalogFly device (of the absolute variety)
# that listens to its analog outputs and converts them into tracker reports.
#
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_port[]

#vrpn_Zaber	Analog0	COM1

################################################################################
# SGI Dial and Button box, raw interface. Runs a dial-and-button box from SGI,
# talking to it through the raw serial interface (not using the GL interface
# supplied by SGI). This allows the box to be opened even if there is nobody
# logged on at the console. Note that to use this on an SGI, you will need to
# configure the port as a serial device, not as a button device, to get it to
# run. Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	[list of buttons to treat as toggles]	int	button_to_toggle

#vrpn_raw_SGIBox	Sgibox0	/dev/ttyS0	0 1 2 3

################################################################################
# SGI Dial and Button box, cooked interface. Runs a dial-and-button box from SGI,
# talking to it through the GL interface supplied by SGI. Note that this can
# only be used on an SGI, and the serial port must be configured as a dial/button
# device and the dial/button server from SGI must be running to use it. Arguments:
#	char	name_of_this_device[]
#	[list of buttons to treat as toggles]	int	button_to_toggle

#vrpn_SGIBOX	Sgibox0	1 2 

################################################################################
# UNC Python button device. UNC has developed a custom button input device, which
# is a 5-button controller that attaches to a parallel port and uses the sense
# lines to return the state of the buttons. This runs the device. Note that on
# Windows NT, you need to have installed the GiveIO driver for this code to
# work. It also works on Linux (no extra drivers needed), but on no other
# architecture. Arguments:
#	char	name_of_this_device[]
#	int	parallel_port_to_use_starting_with_1
#	int	hexadecimal_io_base_number (default address used if left off)

#vrpn_Button_Python	Button0	1

################################################################################
# UNC Joystick driver. UNC has developed a custom-build joybox, with 7 analog
# and 2 button inputs (two 3-axis joysticks and a slider, with a button on top
# of each joystick). This will drive one of these devices, which attaches to
# a serial port on this computer. I'm not sure what the baud rate should be;
# David Harrison might know.
# This driver can be used in conjunction with the JoyFly driver to produce a
# tracker that uses the joystick to fly around. Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device
#	float	minimum_update_rate_from_analogs_even_if_they_dont_move

#vrpn_Joystick	Joybox0	/dev/ttyd1	19200	10.0

################################################################################
# Linux Joystick. Interface to the Linux Joystick driver by Vojtech Pavlik
# included in several Linux distributions. The server code has been tested 
# with Linux Joystick driver version 1.2.14. Yet, there is no way how to
# map a typical joystick's zillion buttons and axes on few buttons and axes
# really used. Unfortunately, even joysticks of the same kind can have 
# different button mappings from one to another.
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_joystick_device[]

#vrpn_Joylin	Joylin0	/dev/js0

################################################################################
# Fakespace Pinch Glove. Drives a Fakespace Pinch Glove device connected to a 
# serial port on this machine. This device has ten buttons-two hands and five
# fingers on each hand. Buttons 0-4 are fingers for the right hand-thumb first 
# and pinkie last- while buttons 5-9 are for the left hand-thumb first. The
# Button is ON when it is touching another finger. Therefore there cannot
# be just one Button ON. Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device

#vrpn_Button_PinchGlove	PinchGlove0		COM1		9600

################################################################################
# Adrienne Electronics Corporation PCI time code driver.  The PCI-VITC board
# for which this driver was developed reads in VITC time codes from an input
# signal.  This will drive one of these devices.
# Arguments:
# char name_of_this_device[]

#vrpn_TimeCode_Generator	TimeGen0

################################################################################
# 5DT glove. Drive a 5dt glove connected on a serial Port. This device uses
# optical fiber to get the finger position. Not all the 5dt gloves are available
# now.
# 2 modes are driven: the first one let the driver get data from the glove
# when requested (we advise this mode). The second one makes the glove send
# data continuously. This mode may saturate the input buffer.
# The manual states that there will be 9 bytes per report, but one group
# has found that they get an extra one: 0x55 at the end of each report.
# So, you can choose whether to use 9 (the default) or 10 now.
# Gesture management is not implemented yet nor the mouse emulation mode
# arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device
#	int	mode_of_data_reporting (1 = on request, 2 = continuously)
#	int	ten_bytes_per_report (0 = no, use 9; 1 = yes)

#vrpn_5dt	glove_5dt	/dev/ttyS0	19200	1 0
#vrpn_5dt	glove_5dt	COM1	19200	1 0

################################################################################
# NRL Serial Mouse. A device made by wiring buttons in parallel with the buttons
# on a serial mouse.  Both mousesystems or microsoft mouse protocols are 
# supported.  Note that the server code makes the connection at the standard
# 1200 baud.  The mouse can be plugged into any serial port -- this driver goes
# directly through the raw port and does not use the built-in mouse drivers.
# NOTE: The middle button on the 3button type is toggled by moving the mouse
# on a surface while not toggling the other two buttons, strange as this may
# seem.  The motion of the mouse is not reported, only the buttons.

#vrpn_Button_SerialMouse	Button0 /dev/ttyd1 mousesystems
#vrpn_Button_SerialMouse	Button0 COM1 mousesystems
#vrpn_Button_SerialMouse	Button0 COM1 3button  
# For a Linux box with a mouse on port 0
#vrpn_Button_SerialMouse	Button0 /dev/ttyS0 3button  
# For a mac with a Keyspan 4-port serial-to-USB converter
#vrpn_Button_SerialMouse	Button0 /dev/tty.USA49W3b12P1.1 3button

################################################################################
# NRL TNG3.  (Totally Neat Gadget) A device made by mindtel, available from
# pulsar.org.  Powered off the serial port control lines, the TNG3 has 8 digital
# and 8 analog inputs.  Analog resolution is 8 bits. Baud rate fixed internally
# at 19200.  
#       char    name_of_this_device[]
#       char    name_of_serial_device[]
#       int     number_of_buttons_to_read (i.e. 8 ==> 0,1,2,3,4,5,6,7)
#       int     number_of_analogs_to_read

#vrpn_Tng3      tng3name    /dev/ttyd2  4 0 
#vrpn_Tng3      tng3name    com1        8 8
#vrpn_Tng3      tng3name    com1        1 1

################################################################################
# Microsoft DirectX compatible force-feedback joystick (or non-force-feedback
# joystick).
#       char    name_of_this_device[]
#       int     number of times per second to read from the device
#       int     number of times per second to update force (0 for non-force device)

#vrpn_DirectXFFJoystick	Joystick0	60	200
#vrpn_DirectXFFJoystick	Joystick0	60	0


################################################################################
# Microsoft DirectX compatible rumble-pad (e.g. Wingman)
#       char    name_of_this_device[]

#vrpn_DirectXRumblePad		RumblePad0

################################################################################
# Microsoft XInput compatible controller (e.g. Xbox 360 gamepad)
#	char	name_of_this_device[]
#	int	userIndex (0 for "Player 1", 1 for "Player 2", etc.)

#vrpn_XInputGamepad		XInput0 0


################################################################################
# Manager for joysticks under windows using standard win32 calls.
# for force feedback support, see DirectX joystick above
#
# Arguments:
#	char	name_of_this_device[]
#	int	joystick Id
#           (1 for first joystick JOYSTICKID1 or 2 for second JOYSTICKID2 only)
# 	int  number of times per second to read from the device
# 	int  readmode : 0 = raw data;
#			1 = 0,1 normalized data;
#			2=-1,1 normalized data 
# 	int  percentage (0 to 100) of deadzone (used mode 1 and 2 only)

#vrpn_Joywin32 joyWin32 1 60 2 35

################################################################################
# Global Haptics GeoOrb serial-line device that contains a number of buttons,
# a thumbwheel, and a trackball.  For current devices, only 19200 baud works.
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device

#vrpn_GlobalHapticsOrb	Orb0	COM1	19200

################################################################################
# SensAble Technologies Phantom force-feedback device opened using the
# GHOST software developer's kit.  For Phantom Desktop systems, you don't
# need to have the user establish the reset position.  For the Premium models,
# you do.
# Arguments:
#	char	name_of_this_device[]
#	int	establish_reset_position	(0 or 1)
#	float	rate_to_send_tracker_reports

#vrpn_Phantom	Phantom	0	60.0

##############################################################################
# Virtual Presence Joystick tracker device. (http://www.vrweb.com)
# Use this driver to read the button states,
# use Flock-of-Birds driver for the position/orientation state
#
# Arguments:
#  char  name_of_this_device[]
#  char  name_of_serial_device[]
#  int   baud_rate_of_serial_device

#vrpn_VPJoystick VPJoystick0 /dev/ttyS0 9600

################################################################################
# Advanced Realtime Tracking GmbH (http://www.ar-tracking.de) DTrack client 
#
# creates as many vrpn_Tracker as there are bodies or Flysticks, starting with the bodies
# creates 2 analogs per Flystick
# creates 8 buttons per Flystick
#
# NOTE: when using DTrack's older output format for Flystick data ('6df'), the numbering
#       of Flystick buttons differs from DTrack documentation (for compatibility with
#       older vrpn releases)
#
# Arguments:
#  char  name_of_this_device[]
#  int   udp_port                               (DTrack sends data to this UDP port)
#
# Optional arguments:
#  float time_to_reach_joy                      (in seconds; see below)
#  int   number_of_bodies, number_of_flysticks  (fixed numbers of bodies and Flysticks)
#  int   renumbered_ids[]                       (vrpn_Tracker IDs of bodies and Flysticks)
#  char  "-"                                    (activates tracing; always last argument)
#
# NOTE: time_to_reach_joy is the time needed to reach the maximum value (1.0 or -1.0) of the
#       joystick of older 'Flystick' devices when the corresponding button is pressed
#       (one of the last buttons amongst the 8); not necessary for newer 'Flystick2' devices
#       with its analog joystick
#
# NOTE: if fixed numbers of bodies and Flysticks should be used, both arguments
#       number_of_bodies and number_of_flysticks have to be set
#
# NOTE: renumbering of tracker IDs is only possible, if fixed numbers of bodies and
#       Flysticks are set; there has to be an argument present for each body/Flystick

#vrpn_Tracker_DTrack DTrack  5000
#vrpn_Tracker_DTrack DTrack  5000  0.5
#vrpn_Tracker_DTrack DTrack  5000  0.5  2 2
#vrpn_Tracker_DTrack DTrack  5000  0.5  2 2  2 1 0 3

################################################################################
# National Instruments Analog Output server.  This will open the board whose
# name is specified, configure the number of channels specified, and set the
# polarity and maximum voltage range at which to drive the channels.
#
# XXX This server is deprecated, please use the vrpn_National_Instruments
# server listed below.
#
# Arguments:
#  char  vrpn_name_for_this_device[]
#  char  name_of_NI_board[]
#  int   number_of_channels
#  int   polarity : 0 = unipolar, 1 = bipolar
#  float min_voltage
#  float max_voltage

#vrpn_NI_Analog_Output	Analog_XY	DAQCard-6036E	2   0	-10.0 10.0
#vrpn_NI_Analog_Output	Analog_ZTweeze	DAQCard-6036E	2   0	-10.0 10.0
#vrpn_NI_Analog_Output	Analog_XYZ	PCI-6733	3   0	-10.0 10.0

################################################################################
# National Instruments A/D, D/A Analog and Analog Output server.  This will open
# the board whose name is specified, configure the number of channels specified,
# and set the polarity and maximum voltage range at which to read and
# drive the channels.
##
# Arguments:
#  char  vrpn_name_for_this_device[]
#  char  name_of_NationalInstruments_board[]
#  int   number_of_input_channels (can be zero)
#  float mininum_delay_between_Analog_Reports (zero for fastest)
#  int   input_polarity : 0 = unipolar, 1 = bipolar
#  int   input_mode : 0 = differential, 1 = ref single-end, 2 = non-ref SE
#  int   input_range : 5 = 5v, 10 = 10v, 20 = 20v
#  int   input_drive_ais : 0 = no, 1 = yes
#  int   input_gain
#  int   number_of_output_channels (can be zero)
#  int   output_polarity : 0 = unipolar, 1 = bipolar
#  float min_out_voltage (used to guard against overdriving devices)
#  float max_out_voltage (used to guard against overdriving devices)

# Input example
#vrpn_National_Instruments MCLXYZIN PCI-6052E 7 0 0 0 10 0 1 0 0 -10.0 10.0
# Output examples
#vrpn_National_Instruments MCLXYZOUT PCI-6733 0 0 0 0 10 0 1 3 0 0.0 10.0
#vrpn_National_Instruments Analog_XY DAQCard-6036E 0 0 0 0 10 0 1 2 1 -10.0 10.0

################################################################################
# Analog Poser. This is a poser that is intended to be used on top of
# an analog output (perhaps a National Instruments board), whose outputs
# directly drive the position of some actuated stage.  It could be used on top
# of any analog output device, in fact.  This device basically takes in poses
# and puts out analog outputs.
#   One analog channel is associated with each axis (X, Y, Z) and rotation about
# each axis (RX, RY, RZ). For each axis, the position (meters) is converted into
# a voltage; the orientation is mapped from a quaternion into Euler angles and
# each of the Euler angles is converted into a voltage (XXX Orientation is not yet
# implemented; the RX,RY, and RZ values must be specified but they are not used).
# XXX Velocity and orientation velocity are not yet supported.
#   Any axis can be disabled by setting the name of its associated device to the
# string "NULL".
#
# Arguments:
#	char  vrpn_name_for_this_device[]
#	int	send_tracker_reports
#	[six lines follow, one for X Y Z RX RY RZ, each with:
#		char	axis_name[]			(X Y Z RX RY RZ in that order)
#		char  vrpn_name_of_the_analog_output_to_use[]
#			(Preface with a * if it uses the same connection)
#		int	channel_of_analog_output_device (First channel is channel 0)
#		float offset
#		float	scale
#		float min_value of workspace
#		float max_value of workspace
#	]

#vrpn_Poser_Analog	Poser0	1
#X	*Analog_XY	0	0.0	1.0	-10	10
#Y	*Analog_XY	1	0.0	1.0	-10	10
#Z	*Analog_ZTweeze	0	0.0	1.0	-10	10
#RX	NULL	0	0.0	1.0	-10	10
#RY	NULL	0	0.0	1.0	-10	10
#RZ	NULL	0	0.0	1.0	-10	10

# Poser to drive Mad City Labs stage from an input value of
# 0 to 100 microns to an output (through a National Instruments
# D/A card) of 0-10 volts.
#vrpn_Poser_Analog	Poser0	1
#X	*MCLXYZOUT	0	0.0	0.1	0	100
#Y	*MCLXYZOUT	1	0.0	0.1	0	100
#Z	*MCLXYZOUT	2	0.0	0.1	0	100
#RX	NULL	0	0.0	1.0	-10	10
#RY	NULL	0	0.0	1.0	-10	10
#RZ	NULL	0	0.0	1.0	-10	10

################################################################################
# Nikon microscope connected to PC via serial port.  Currently only controls
# the focus of the microscope using an analogout and reads the focus position
# using an analog.
#
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]

#vrpn_nikon_controls	nikon	COM1

################################################################################
# Tektronix 4662 plotter.  Attaches to a serial port.  Acts as both a poser and
# a tracker.  Reports positions 4x per second plus when a move command completes.
# Multiple move commands issued before they complete will result in only the last
# one being executed.
#
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device

#vrpn_Tek4662	Tek4662	COM1	1200

###############################################################################
# keyboard and mouse button is a tracker with button system
# XXX These have been removed and replaced with vrpn_Mouse
# and vrpn_Keyboard.  Use the clutch option on vrpn_AnalogFly to
# replicate the mouse behavior.  The vprn_Keyboard does not
# enable key mapping, just sends all of the keys' scancodes
# through.

################################################################################
# US Digital A2 Absolute Encoder Analog Input server.  This will open the COM 
# port specified, configure the number of channels specified, and report
# Absolute Encoder values in tenths of a degree from 0 to 3599.
#
# Arguments:
#	char	name_of_this_device[]
#       int     COM_port.  If 0, search for correct COM port.
#       int     number_of_channels
#	int	0 to report always, 1 to report on change only (optional, default=0)

#vrpn_Analog_USDigital_A2	Analog0 1	2

################################################################################
#      This is a driver for National Instruments DAQCard-
# DIO-24, a PCMCIA card, which provides 24-bit digital I/O.
#
# Arguments:
#	char	name_of_this_device[]
#       int     number_of_channls to read: 1-24 (optional.  default=24).

#vrpn_Button_NI_DIO24	Button0	1


##############################################################################
#PhaseSpace OWL server.  This device type is not compiled by default, since
#it uses a proprietary library.  However, you can get it to compile by 
#defining VRPN_INCLUDE_PHASESPACE and including the appropriate libraries
#and headers when compiling (See vrpn_Configure.h).   
#
#Arguments:
#       char	name_of_this_tracker[]   #Tracker0, Tracker1, ... etc       
#       char    location_of_OWL_device[] #typically localhost, or ip address
#       float   frame_rate               #between 0.0 and 480.0
#       int     read_till_most_recent    #0 or 1.  
#       int     slave_mode               #0 or 1.
#       [Additional lines specifying markers and rigid bodies]
#
#Specifying a frequency >0 will start streaming immediately at startup.
#To delay this, set the frequency to zero and adjust the update rate later.
#
#Specifying 1 for read_till_most_recent will cause the server to drop frames
#in order to get the most recent data on every run through the mainloop.
#This may be desirable for most VR applications and for slower machines.
#
#The format of the additional lines is as follows:
#
#Example:
#
#vrpn_Tracker_PhaseSpace Tracker0 localhost 480.0 1 0 
#<owl>   
#0 :     rbnew                            
#1 :     rb+     0      0       300     0     
#2 :     rb+     1      300     0       0     
#3 :     rb+     2      -300    0       0     
#4 :     rb+     3      0       76      -200  
#5 :     pt      4                      
#6 :     pt      5                      
#7 :     pt      6    #this is a comment                  
#8 :     pt      8                      
#9 :     pt      9                      
#</owl>
#
#
#
#       In regular expression syntax:
#       sensornumber : spectype led_id [xcoord  ycoord  zcoord]
#
#       The <owl> and </owl> tags indicate the start and end of the marker
#       and rigid body specifications.  Each line inside the tags correspond
#       to a sensor specified by the first number in the line.  Register 
#       callbacks as necessary.  The # character will cause the rest of
#       the line to be ignored.  Do not assign duplicate sensors.
#
#       There are 4 spectypes: "rbnew", "rb+", and "pt".
#
#       "pt" indicates a normal marker specification.
#       The number following it indicates the led id to assign to that sensor.
#       No further arguments are needed for the rest of the line. The vrpn 
#       server will return position data for that marker but no orientation 
#       data.  
#
#       "rbnew" indicates a new rigid body specification.  The lines following
#       it must be "rb+" lines, indicating the addition of markers to the
#       rigid body.  The "rb+" lines must have the x,y, and z coordinates of 
#       the rigid body marker specified after the led id.  The rigid body
#       itself is assigned the sensor of the "rbnew" line, and the markers
#       in the rigid body are given the sensor numbers of the "rb+" lines.
#       The rigid body specification continues until another "rbnew" line is 
#       encountered or until the </owl> tag.  If "pt" lines are mixed in, they
#       do not affect the rigid body. Rigid bodies will return an orientation
#       as well as positional data.  
#
#       Empty or invalid lines inside the <owl> and </owl> tags are also
#       ignored.
#
#       Care must be taken to AVOID specifying the same led id or sensor twice,
#       sensors and led ids should be unique.
#
#       The OWL server (not just the vrpn server) must still be configured to
#       track the specified markers.  Consult the PhaseSpace documentation to
#       see how.
#
#
#       Velocities and accelerations are not currently supported.
#
#       The frequency of streaming can be varied with set_update_rate()
#       in vrpn_Tracker_Remote. To stop streaming, set the update rate to
#       zero.
#               
#       For support, questions, comments, or bug reports please send emails 
#       to:  support@phasespace.com

#vrpn_Tracker_PhaseSpace Tracker0 localhost 480.0 1 0
#<owl>
#0 :     pt      0      #to sensor 0 assign led 0
#1 :     pt      1      #to sensor 1 assign led 1
#2 :     pt      2      #to sensor 2 assign led 2
#3 :     pt      3      #to sensor 3 assign led 3
#</owl>

################################################################################
# Generic Auxiliary Logger. This is a server that will listen for requests to
# produce additional log files and the name of the connection it should make the
# log files for.  It can only have one set of such logs open (can be more than
# one log but all for the same connection).  There are two arguments:
#	char	name_of_this_device[]
#	char	name_of_connection_to_log

#vrpn_Auxiliary_Logger_Server_Generic Logger0 localhost

################################################################################
# Imager Stream Buffer. This is a server that will listen for requests to
# produce additional log files and the name of the connection it should make the
# log files for.  It can only have one set of such logs open (can be more than
# one log but all for the same connection).  The "local" log files are with
# respect to the machine where this server is running, and the "remote" ones
# are with respect to the vrpn_Imager_Server it has connected to (which may
# be on yet a third machine compared to the client machine).
# There are two arguments:
#	char	name_of_this_device[]
#	char	name_of_imager_server_to_log

#vrpn_Imager_Stream_Buffer ImageStream0 TestImage@localhost

################################################################################
# X-Keys devices from P.I. Engineering.  There are four devices we have
# drivers for.  The only argument is the name of the device to open.  The Pro
# and Joystick models have not been tested.
#
# There is one argument:
#	char	name_of_this_device[]

#vrpn_Xkeys_Desktop xkeys0
#vrpn_Xkeys_Pro xkeys0
#vrpn_Xkeys_Joystick xkeys0
#vrpn_Xkeys_Jog_And_Shuttle xkeys0

################################################################################
# Space Navigator, Space Traveler, and Space Mouse devices from 3DConnexion.
# The only argument is the name of the device to open.
#
# There is one argument:
#	char	name_of_this_device[]
#
# On Linux, make sure the HID and evdev drivers are running so that these
# devices will be recognized:
#  Start a separate Root shell:
#  cd .../vrpn/server_src/pc_linux
#  lsmod
#  modprobe evdev
#  modprobe hid
#  lsmod
#  (check that evdev and hid are running)

#vrpn_3DConnexion_Navigator device0
#vrpn_3DConnexion_Traveler device0
#vrpn_3DConnexion_SpaceMouse device0
#vrpn_3DConnexion_SpaceExplorer device0
#vrpn_3DConnexion_SpaceBall5000 device0


################################################################################
# Open the mouse as an analog and button devices.  There is an implementation
# under Windows and another under Linux (using GPM).  There are two analog
# channels, reporting in the range [0..1] as the mouse moves across the screen.
# There are 3 button channels: left, middle, right.
#
# There is one argument:
#	char	name_of_this_device[]

#vrpn_Mouse	Mouse0

################################################################################
# Open the keybaord as a button device.  There is an implementation
# under Windows.  There are 256 buttons, and they are triggered according
# to the scan code that they represent.
#
# There is one argument:
#	char	name_of_this_device[]

#vrpn_Keyboard	Keyboard0

################################################################################
# MotionNode inertial tracking system.
#
# There are four arguments:
#	char	name_of_this_device[]
#	int	num_sensors
#	char	address
#	int	port

#vrpn_Tracker_MotionNode Tracker0 1 FIXME 1

################################################################################
# Nintendo Wii Remote Controller
#	char	name_of_this_device[]
#	int	userIndex (0 for "Player 1", 1 for "Player 2", etc.)

#vrpn_WiiMote		WiiMote0 0
