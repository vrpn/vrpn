# vrpn.cfg SAMPLE for VRPN version @CONFIG_VERSION@

################################################################################
################################################################################
# This file provides comments and examples for the vrpn.cfg file that is read
# by the vrpn_server application when it starts up. This is a generic server
# application that can start up many but maybe not all servers.
#
# This has sample lines for a vrpn.cfg file.  If you get a new device working,
# add a line for it here.  DO NOT remove lines from this file (unless
# devices are declared obsolete) - just change the actual vrpn.cfg to match
# your application.
#
# All examples in the file are preceded by comment characters (#). To actually
# use one of these examples, remove that character from the beginning of all the
# examples that you want to use, and edit those lines to suit your environment.
################################################################################

################################################################################
# NULL Tracker. This is a "device" that reports the Identity transformation for
# each of its sensors at the specified rate. It can be used to verify
# connections are working and for other tests of VRPN.
# There are three arguments:
#	char	name_of_this_device[]
#	int	number_of_sensors
#	float	rate_at_which_to_report_updates

#vrpn_Tracker_NULL	Tracker0	2	2.0

################################################################################
# Spin Tracker. This is a "device" that reports a spinning rotation at the
# origin for each of its sensors at the specified rate.  It can be used to
# provide smooth motion to debug rendering systems.
# There are seven arguments:
#	char	name_of_this_device[]
#	int	number_of_sensors
#	float	rate_at_which_to_report_updates
#	float	x_of_axis_to_spin_around
#	float	y_of_axis_to_spin_around
#	float	z_of_axis_to_spin_around
#	float	rotation_rate_around_axis_in_Hz

#vrpn_Tracker_Spin	Tracker0	1	200.0  0.0 1.0 0.0  0.1

################################################################################
# WintrackerIII from VR SPace
# Emiliano Pastorelli - Institute of Cybernetics, Tallinn (Estonia)
#
# Several other commands are available to control the device, a future version of the server will implement them too
#
#	char name_of_the_device[]
#	activate sensor0 activate (1=activated, 0=deactivated)
#	activate sensor1 activate (1=activated, 0=deactivated)
#	activate sensor2 (1=activated, 0=deactivated)
#	activate range extender (1=activated, 0=deactivated)
#	hemisphere of operation (X = front hemisphere with X>0; Z = upper hemisphere with Z<0 )
#

#vrpn_Tracker_Wintracker Wintracker0	1	0	0	0	X

################################################################################
# Example Button server. This is a "device" that reports on and off for
# each of its buttons at the specified rate. It can be used to verify connections
# are working and for other tests of VRPN. There are three arguments:
#	char	name_of_this_device[]
#	int	number_of_buttons
#	float	rate_at_which_the_buttons_toggle		(transitions/second)

#vrpn_Button_Example	Button0	2	2.0

################################################################################
# Example Dial server. This is a "device" that reports constant rotations for
# each of its dials at the specified rate. It can be used to verify connections
# are working and for other tests of VRPN. There are four arguments:
#	char	name_of_this_device[]
#	int	number_of_dials
#	float	rate_at_which_the_dials_spin		(revolutions/second)
#	float	rate_at_which_to_report_updates		(updates/second)

#vrpn_Dial_Example	Dial0	2	2.0	10.0

################################################################################
# Flock-of-birds Tracker. Runs an Ascension Flock of Birds tracker that is
# attached to a serial port on this machine. Note that there is another driver
# (listed below) that runs the Flock when each sensor is connected to its own
# serial line. Arguments:
#   char    name_of_this_device[]
#   int	    number_of_sensors
#   char    name_of_serial_device[]
#   int	    baud_rate_of_serial_device
#   int     invert_quaternion (0 = no, 1 = yes)
#   char    useERT  (OPTIONAL; defaults to yes)
#   char[2] active_hemisphere (OPTIONAL; defaults to +z)
#
# NOTE: for useERT: use nothing, y or Y if you have an extended range
# transmitter, use N or n if not (added by David Nahon for Virtools
# VRPack/SAS Cube.
# NOTE: The "invert_quaternion" parameter was added because there was a
# conflict between the code that had been around since VRPN started and
# the Flock documentation -- it looks like most people had been using the
# Flock in the "wrong" hemisphere, which inverted the orientation relative
# to the position.  The old behavior is obtained by specifying "1".  Not
# inverting it is specified using "0".
# NOTE: active hemisphere is one of "+x", "-x", "+y", "-y", "+z", "-z"
# If "active_hemisphere" is not specified, it defaults to +z.


#vrpn_Tracker_Flock	Tracker0	4	/dev/ttyS0	115200	1

# If you have to FOB, with no Extended Range ctrler/transmitter, on Windows,
# with -x as the active hemisphere, use

#vrpn_Tracker_Flock	Tracker0	2	COM1	38400	1	N  -x

# Watch: be sure that the serial baud rate dip switches (the 3 on the left)
# of your master flock are properly set.
# You should try baud rates like 38400 before trying to go higher
# In normal address mode - less than 14 fob units - your switch should be:
# 0 1 2 3 4 5 6 7
# 0 0 1	X X X X 0 	2400
# 0 1 0	X X X X 0	4800
# 0 1 1	X X X X 0	9600
# 1 0 0	X X X X 0	19200
# 1 0 1	X X X X 0	38400
# 1 1 0	X X X X 0	57600
# 1 1 1	X X X X 0	115200
#
# X X X X are used for coding the FOB address, they must be set correctly,
# even if you are only using 1 unit (standalone mode)
# the settings should be (in normal address mode):
# 3 4 5 6
# 0 0 0 1	for the first unit
# 0 0 1 0	for the second unit
# 0 0 1 1	for the third
# 0 1 0 0	for the fourth
# 0 1 0 1	for the fifth
# ...
#
############################################################################
# WATCH WATCH WATCH WATCH WATCH WATCH WATCH WATCH WATCH WATCH WATCH WATCH
###################
#
# On windows at least, it might be necessary to cut your serial cable so as
# to only have Transmit, Receive and Ground pins. Even if CBIRDS or WINBIRDS
# are fine with a cable, it doesn't mean that this cable will please vrpn.
# This limitation should have been fixed with version 06.05.
#
###################

################################################################################
# Flock-of-birds in parallel Tracker. Runs an Ascension Flock of Birds tracker
# that has its source and each sensor plugged into its own serial port on this
# machine (perhaps through a Cyclades multi-port serial card). This mode of
# operation increases the throughput and decreases the latency of tracker reports.
# The arguments match those of the Flock-of-birds tracker from above, with the
# addition of the name of the serial ports for each of the sensors added at the
# end. Arguments (all on the same line):
#	char	name_of_this_device[]
#	int	number_of_sensors
#	char	name_of_serial_device_for_controller[]
#	int	baud_rate_of_serial_device
#	int   invert_quaternion (0 = no, 1 = yes)
#	[one for each sensor]	char	name_of_serial_device_for_sensor[]
#
# NOTE: The "invert_quaternion" parameter was added because there was a
# conflict between the code that had been around since VRPN started and
# the Flock documentation -- it looks like most people had been using the
# Flock in the "wrong" hemisphere, which inverted the orientation relative
# to the position.  The old behavior is obtained by specifying "1".  Not
# inverting it is specified using "0".

#vrpn_Tracker_Flock_Parallel	Tracker0	4	/dev/ttyC4	115200	1	/dev/ttyC0 /dev/ttyC1 /dev/ttyC2 /dev/ttyC3
#vrpn_Tracker_Flock_Parallel	Tracker0	2	COM1	115200	1	COM2 COM3

################################################################################
# Fastrak Tracker. Runs a Polhemus Fastrak tracker that is attached to a serial
# port on this machine. This driver will also run an InterSense IS600 or IS900
# tracker, but you will want to include extra initialization code (as described
# below) to set up the ultrasonic pip information, wand devices, stylus devices
# and so forth.  Arguments that go on the first line:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device
#
# It is possible to add additional commands that will be sent to the tracker
# by putting the backslash character (\) at the end of the config line. This
# will cause the following line to be read in and sent to the Fastrak during
# the reset routine. You can add additional lines by putting a slash at the
# end of each command line but the last. Each line will be sent to the Fastrak
# with a newline at the end of it. If a line starts with an asterisk (*), then
# it is treated as a line telling how long to sleep, with the integer number of
# seconds following the *.
#
# If one or more sensors on the Fastrak have a stylus button on them, use
# the "FTStylus" command after the reset command lines (if any).  There should
# be a front-slash "/" character at the end of the line before the FTStylus
# command.  The command takes two arguments: the name of the button device
# that will report the buttons and the sensor number to which the button is
# attached (the first sensor is sensor 0).
#
# Commands to add Joysticks (2 buttons) or Wands (5 buttons and 2 analogs) to
# the various sensors on the Isense900 are done by adding Stylus and
# Wand command lines after the reset command lines.  Each of these lines
# takes two arguments: the name of the button (for Stylus) or button and
# analog (for Wand) servers, and the sensor number (starting from 0).  The
# Wand line takes eight additional parameters, which specify the scaling
# and clipping behavior of the two directions on the analog joystick.  Each
# set of for is the min, lowzero, hizero, and max values: these are mapped
# to -1, 0,0, and 1 (all values between lowzero and hizero are mapped to 0).
# Start with these at -1,0,0,1 and use the 'printcereal' program or some other
# method to read them and see what the range of acheivable values is.  Then,
# set them to slightly conservative values so that the whole range is covered
# and the analogs will report zero when the joystick is centered. The
# presence of these lines is indicated by placing them after any additional
# reset command lines, by ending the line preceding them with the front slash
# "/" character.
#
# Remember that the "remote" button object is not the same as the the tracking
# device, so be sure to use a remote button object that connects to the button
# rather than the tracker.  The button device name is defined on the stylus or
# wand line in the config file, and should not be the same as the tracker.  In
# the case described by the example configuration below, if the name of the
# machine running the server is "myis900server" you would connect to the tracker
# as "Isense900@myis900server" and to the buttons on the stylus as
# "Stylus0@myis900server":
#
# Note that this frontslash and backslash-notation can only be used for the
# Fastrak/Isense tracker, not to extend the line for any other type of device
# listed in this configuration file.

# Vanilla Fastrak on on a Unix box
#vrpn_Tracker_Fastrak	Fastrak0	/dev/ttyS0	19200

# Fastrak with a stylus on sensor zero on a Windows box
#vrpn_Tracker_Fastrak	Tracker0	COM1	115200 /
#FTStylus Stylus0 0

# IS600 and its pip settings
#vrpn_Tracker_Fastrak	Isense600	/dev/ttyS0	19200 \
#MCc\
#*5\
#MCM1,1,0.0900,0.0000,-0.2210,0.00,0.00,-1.00,89\
#MCM1,2,-0.0566,0.0000,-0.2210,0.00,0.00,-1.00,87\
#MCM2,1,0.0900,0.0000,-0.2210,0.00,0.00,-1.00,66\
#MCM2,2,-0.0566,0.0000,-0.2210,0.00,0.00,-1.00,71\
#MCM3,1,0.1237,-0.0762,-0.0424,0.00,0.00,-1.00,82\
#MCM3,2,0.1237,0.0762,-0.0424,0.00,0.00,-1.00,77\
#MCe\
#*10

# IS900 with a wand on the first sensor and a stylus on the third:
#vrpn_Tracker_Fastrak	Isense900	COM1	115200 /
#Wand		Wand0		0	-1.0 0.0 0.0 1.0  -1.0 0.0 0.0 1.0 /
#Stylus	Stylus0	2

################################################################################
# Isotrak Tracker. Runs a Polhemus Isotrak tracker that is attached to a serial
# port on this machine. Arguments that go on the first line:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device
#
# It is possible to add additional commands that will be sent to the tracker
# by putting the backslash character (\) at the end of the config line. This
# will cause the following line to be read in and sent to the Isotrak during
# the reset routine. You can add additional lines by putting a slash at the
# end of each command line but the last. Each line will be sent to the Isotrak
# with a newline at the end of it. If a line starts with an asterisk (*), then
# it is treated as a line telling how long to sleep, with the integer number of
# seconds following the *.

#vrpn_Tracker_Isotrak	TrackerIsotrak	/dev/ttyS0	115200 \
#H1,0,1,0

################################################################################
# Liberty Tracker. Runs a Polhemus Liberty tracker that is attached to a serial
# port (perhaps a USB-to-RS232 adapter) on this machine.  Arguments that go on
# the first line.
#	char	name_of_this_device[]
#	char	name_of_serial_or_usb_device[]
#	int	baud_rate_of_serial_device (not used when the device is USB)
#	int	number_of_chars_in_whoami_response (optional)
#
# It is possible to add additional commands that will be sent to the tracker
# by putting the backslash character (\) at the end of the config line. This
# will cause the following line to be read in and sent to the Liberty during
# the reset routine. You can add additional lines by putting a slash at the
# end of each command line but the last. Each line will be sent to the Fastrak
# with a newline at the end of it. If a line starts with an asterisk (*), then
# it is treated as a line telling how long to sleep, with the integer number of
# seconds following the *.
#
# If one or more sensors on the Liberty have a stylus button on them, use
# the "Stylus" command after the reset command lines (if any).  There should
# be a front-slash "/" character at the end of the line before the Stylus
# command.  The command takes two arguments: the name of the button device
# that will report the buttons and the sensor number to which the button is
# attached (the first sensor is sensor 0).
#

# -------------------------------------------
# Example when Liberty is attached via USB
# The BAUD Rate is needed, although it is not used

#vrpn_Tracker_Liberty	Liberty	/dev/usb/ttyUSB0	115200

#--------------------------------------------
# Example when Liberty is attached via Serial

#vrpn_Tracker_Liberty   Liberty /dev/ttyS0        115200

#--------------------------------------------
# Example when Liberty is attached via Serial with a non-standard whoami length

#vrpn_Tracker_Liberty   Liberty /dev/ttyS0        115200	247

#--------------------------------------------
# Liberty attached via Serial with styluses on sensors zero and three
#vrpn_Tracker_Liberty	Tracker0	/dev/ttyS0	115200 /
#Stylus Stylus0 0 /
#Stylus Stylus1 3

################################################################################
# High Speed Liberty Latus Tracker. Runs a Polhemus Liberty Latus tracker that
# is attached to a USB port on this machine.  Arguments that go on the first line
#	char	name_of_this_device[]
#       int     number_of_markers_to_detect
#	int	baud_rate_of_usb_device
#	int	number_of_chars_in_whoami_response (optional)
#
# It is possible to add additional commands that will be sent to the tracker
# by putting the backslash character (\) at the end of the config line. This
# will cause the following line to be read in and sent to the Liberty during
# the reset routine. You can add additional lines by putting a slash at the
# end of each command line but the last. Each line will be sent to the Fastrak
# with a newline at the end of it. If a line starts with an asterisk (*), then
# it is treated as a line telling how long to sleep, with the integer number of
# seconds following the *.

# -------------------------------------------
# Example when Liberty Latus is attached via USB
# The BAUD Rate is needed, although it is not used

#vrpn_Tracker_LibertyHS   LibertyHS   3   115200

################################################################################
# InterSense tracker using the Intersense-provided library to communicate
# with the tracker.  This device type is not compiled by default, since it uses
# a proprietary library.  However, you can get it to compile by defining
# VRPN_INCLUDE_INTERSENSE when compiling.  Note that the Fastrak driver will
# run IS-600 and IS-900 trackers without the proprietary library, so you might
# try that as well.
#
# You can include extra initialization code (as described
# below) to set up the ultrasonic pip information, wand devices, stylus devices
# and so forth.  Arguments that go on the first line:
#       char    name_of_this_device[]
#       char    name_of_serial_device[] - this can be COM1-4 or AUTO
#                                     AUTO will automatically find USB and
#                                     serial trackers. Use COM1-4 only if you
#                                     have more than one serial tracker.
#                                     You should use COM1-4 on unix as well,
#                                     as these just tell the isense library
#                                     to look in serial port 1-4.
#                                     I guess you can't have >1 USB trackers.
#     char "IS900time"		- use the IS900 timestamps (optional)
#     char "ResetAtStartup"	- resets all boresight and heading, on intertrax,
#			          equivalent to push the reset button
#
# It is possible to add additional commands that will be sent to the tracker
# by putting the backslash character (\) at the end of the config line. This
# will cause the following line to be read in and sent to the InterSense during
# the reset routine. You can add additional lines by putting a slash at the
# end of each command line but the last. Each line will be sent to the InterSense
# with a newline at the end of it. If a line starts with an asterisk (*), then
# it is treated as a line telling how long to sleep, with the integer number of
# seconds following the *.
#
# Commands to add Joysticks (2 buttons) or Wands (5 buttons and 2 analogs) to
# the various sensors on the Isense900 are done by adding Stylus and
# Wand command lines after the reset command lines.  Each of these lines
# takes two arguments: the name of the button (for Stylus) or button and
# analog (for Wand) servers, and the sensor number (starting from 0).  The
# Wand line takes eight additional parameters, which specify the scaling
# and clipping behavior of the two directions on the analog joystick. Each
# set of for is the min, lowzero, hizero, and max values: these are mapped
# to -1, 0,0, and 1 (all values between lowzero and hizero are mapped to 0).
# Start with these at -1,0,0,1 and use the 'printcereal' program or some other
# method to read them and see what the range of acheivable values is. Then,
# set them to slightly conservative values so that the whole range is covered
# and the analogs will report zero when the joystick is centered. The
# presence of these lines is indicated by placing them after any additional
# reset command lines, by ending the line preceding them with the front slash
# "/" character.
#
# Remember that the "remote" button object is not the same as the the tracking
# device, so be sure to use a remote button object that connects to the button
# rather than the tracker.  The button device name is defined on the stylus or
# wand line in the config file, and should not be the same as the tracker. In
# the case described by the example configuration below, if the name of the
# machine running the server is "myis900server" you would connect to the tracker
# as "Isense900@myis900server" and to the buttons on the stylus as
# "Stylus0@myis900server":
#
# Note that this frontslash and backslash-notation can only be used for the
# Fastrak and InterSense tracker, not to extend the line for any other
# type of device
# listed in this configuration file.
#
# Note that this driver expects the device to be set to output centimeters, and will convert
# the positions to meters. It is recommanded to permanently set the units in the eeprom of your device.
# If this is not possible, you should add in this file the "u" reset command so as to have vrpn
# tell your device to use centimeters
#
#Vanilla InterSense
#vrpn_Tracker_InterSense Tracker0 AUTO IS900time

# Vanilla InterSense using IS900 timing, with wand in port B (and possibly head tracker in port A)
#vrpn_Tracker_InterSense Tracker0 AUTO IS900time /
#Wand            Wand0           1       -1.0 0.0 0.0 1.0  -1.0 0.0 0.0 1.0

# IS600 and its pip settings
#vrpn_Tracker_InterSense        Isense600       COM1 \
#MCc\
#*5\
#MCM1,1,0.0900,0.0000,-0.2210,0.00,0.00,-1.00,89\
#MCM1,2,-0.0566,0.0000,-0.2210,0.00,0.00,-1.00,87\
#MCM2,1,0.0900,0.0000,-0.2210,0.00,0.00,-1.00,66\
#MCM2,2,-0.0566,0.0000,-0.2210,0.00,0.00,-1.00,71\
#MCM3,1,0.1237,-0.0762,-0.0424,0.00,0.00,-1.00,82\
#MCM3,2,0.1237,0.0762,-0.0424,0.00,0.00,-1.00,77\
#MCe\
#*10

# IS900 with a wand on the first sensor and a stylus on the third:
#vrpn_Tracker_InterSense        Isense900       COM1 /
#Wand           Wand0           0       -1.0 0.0 0.0 1.0  -1.0 0.0 0.0 1.0 /
#Stylus Stylus0 2

# Intertrax2 on USB, With automatic reset at startup
#vrpn_Tracker_InterSense        Tracker0       AUTO  ResetAtStartup

################################################################################
# Dynasight Tracker. Runs an Origin System's DynaSight tracker connected to a
# serial port on this machine. arguments:
#	char	name_of_this_device[]
#	int	number_of_sensors
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device

#vrpn_Tracker_Dyna	Tracker0	1	/dev/ttyS0	19200

#vrpn_Tracker_Dyna	Tracker0	1	COM1		19200

################################################################################
# Crossbow Tracker. Runs a Crossbow Technology RGA300-series tracker that is
# attached to a serial port on this machine. There are four arguments:
#       char    name_of_this_device[]
#       char    name_of_serial_device[]
#       int             baud_rate_of_serial_device (should be 38400)
#       float   linear_acceleration_sensitivity (Gs; default is 2.0)
#       float   angular_rate_sensitivity (degrees per second; default is 100)

#vrpn_Tracker_Crossbow  Tracker0        COM1:   38400   2.0     100

###############################################################################
# 3d Microscribe is a mechanical tracker the nesseccary params are
# name  port baudrate
# additional params are offsetx offsety offsetz scale
# offsets are in meters.  Scale is an abomination in VRPN; all
# trackers report in meters.
#

#vrpn_3DMicroscribe Microscribe COM1 19200 0.3 -0.1 -0.2 1

################################################################################
# Serial 5DT glove with 16 sensors.  This driver reports the 16 channels as analog
# devices.  If you want to treat them as buttons, then also add the entry
# for the vrpn_Button_5DT_Server below, connecting it to the output of this
# server.
#
# This server does not work with the previous version of the glove.
# For other variations of 5DT datagloves, see vrpn_5dt and vrpn_Analog_5dtUSB
#
#  arguments:
#       char    name_of_this_device[]
#       char    name_of_serial_device[]
#       int     baud_rate_of_serial_device

#vrpn_5dt16    glove_5dt16     COM1    19200

################################################################################
#
# Use the 5dtglove16 as button device.  Use in conjunction with the vrpn_5dt16
# device above to turn the analog reports into button press/release when the
# sensors cross the threshold.
#
# arguments:
#       char name_of_this_device[]
#       char name_of_the_glove device[]
#       double threshold_toggle_point_between_pressed_and_unpressed[16]

#vrpn_Button_5DT_Server glove_5dt_button glove_5dt16 1794 2171 2110 2610 1707 2673 2459 1493 3029 2301 1936 3007 2302 1635 0 0

################################################################################
# AnalogFly Tracker. This is a tracker that is intended to be used on top of
# a joystick or motion tracker of some kind to turn it into a moving or flying
# device. It could be used on top of any analog device, in fact.
#   This device basically takes in analog signals and puts out transformation
# matrices. It should supercede the JoyFly tracker, since it is more general.
#   There are two kinds of JoyFly's: absolute ones and differential ones.  For
# absolute ones, the analog value is mapped directly to position or orientation
# on each axis.  For differential ones, the values are used to create a
# "change" matrix that is applied once per interval, accumulating changes as
# it goes; this enables the user to "fly" along by holding a joystick forward,
# for example.
#   One analog channel is associated with each axis (X, Y, Z) and rotation about
# each axis (RX, RY, RZ). For each axis, the value is converted to a position
# (meters) or speed (meters/second) for absolute trackers; or into an
# orientation (revolutions) or angular velocity (revolutions/second) by first
# subtracting an offset, then thresholding it to see if it is far enough from
# zero, then (if it is) scaling it and taking it to a power (to allow nonlinear
# speedup as the stick is pushed far from center).
#   A button can be associated with a reset function, which will take the
# device back to center (identity transformation). The device will also recenter
# when the first connection is made to the server it is running on. (Centering
# has no effect on absolute AnalogFlys).
#   A button can be associated with a clutch function, which will mean that
# the device will not move unless the clutch is pressed, so you can use it
# like a mouse and continue to move by pulling to the right with the button
# down and then to the left with the button up.  For differential analogflys,
# clutching makes the tracker not move unless the button is pressed.  For
# absolute ones, it only moves when the button is pressed and the mouse is
# moving; it offsets to enable long-range motions in a finite tracking area,
# as with a mouse.
#   Any axis or the reset button can be disabled by setting the name of its
# associated device to the string "NULL".
#   Note that you could have multiple of these devices running simultaneously,
# each with a different name and interaction metaphor. The user could then
# connect to their favorite one. Arguments:
#	char  name_of_this_device[]
#	float update_rate_to_send_tracker_reports
#	char  type[] = "absolute" or "differential"
#	[six lines follow, one for X Y Z RX RY RZ, each with:
#		char	axis_name[]			(X Y Z RX RY RZ in that order)
#		char	name_of_analog_device[]		(start with * for local)
#		int	channel_of_analog_device
#		float offset
#		float	threshold
#		float	scale
#		float	power
#	]
#	[New line to describe reset button, with:
#		char	"RESET"
#		char	name_of_button_device[]		(start with * for local)
#		int	which_button_to_use
#	]
#	[New line to describe clutch button, with:
#		char	"CLUTCH"
#		char	name_of_button_device[]		(start with * for local)
#		int	which_button_to_use
#	]
#   [New line to indicate use of world frame for translation and rotation,
#   instead of local frame. Useful for a simulated wand when doing desktop
#   testing of immersive apps - easier to keep under control.
#		char	"WORLDFRAME"
#	]

#vrpn_Tracker_AnalogFly Tracker0 60.0 absolute
#X  *Mouse0 0 0.5 0.0 2.0 1.0
#Y  *Mouse0 1 0.5 0.0 2.0 1.0
#Z  NULL 2 0.0 0.0 1.0 1.0
#RX NULL 3 0.0 0.0 1.0 1.0
#RY NULL 4 0.0 0.0 1.0 1.0
#RZ NULL 5 0.0 0.0 1.0 1.0
#RESET NULL 0
#CLUTCH *Mouse0 0

#vrpn_Tracker_AnalogFly	Tracker0	60.0	absolute
#X	*CerealBox0	4	0.0	0.021	1.0	1.0
#Y	*CerealBox0	5	0.0	0.021	1.0	1.0
#Z	*CerealBox0	6	0.0	0.021	3.0	1.0
#RX	*CerealBox0	0	0.0	0.021	1.0	1.0
#RY	*CerealBox0	1	0.0	0.021	1.0	1.0
#RZ	*CerealBox0	2	0.0	0.021	3.0	1.0
#RESET	*CerealBox	3
#CLUTCH	NULL 0

#vrpn_Tracker_AnalogFly	Tracker0	60.0	differential
#X	*Magellan0	0	0.0	0.0	2.0	1.0
#Y	*Magellan0	1	0.0	0.0	2.0	1.0
#Z	*Magellan0	2	0.0	0.0	2.0	1.0
#RX	*Magellan0	3	0.0	0.0	2.0	1.0
#RY	*Magellan0	4	0.0	0.0	2.0	1.0
#RZ	*Magellan0	5	0.0	0.0	2.0	1.0
#RESET	NULL	0
#CLUTCH	NULL 0

# For a good simulated wand for testing VR Juggler applications with a SpaceMouse:
#vrpn_Tracker_AnalogFly	Tracker0	60.0	differential
#X	*Magellan0	0	0.0	0.0	20.0	    1
#Y	*Magellan0	1	0.0	0.0	20.0	    1
#Z	*Magellan0	2	0.0	0.0	20.0	    1
#RX	*Magellan0	3	0.0	0.01	-5	1.0
#RY	*Magellan0	4	0.0	0.01	-5	1.0
#RZ	*Magellan0	5	0.0	0.01	-5	1.0
#RESET	NULL	0
#CLUTCH	NULL 0
#WORLDFRAME

#vrpn_Tracker_AnalogFly	Tracker0	60.0	absolute
#X	NULL		0	0.0	0.0	1.0	1.0
#Y	NULL		0	0.0	0.0	1.0	1.0
#Z	NULL		0	0.0	0.0	1.0	1.0
#RX	*Radamec0	1	0.0	0.0	-0.0027777777	1.0
#RY	NULL		0	0.0	0.0	1.0	1.0
#RZ	*Radamec0	0	0.0	0.0	0.0027777777	1.0
#RESET	NULL	0
#CLUTCH	NULL 0

#vrpn_Tracker_AnalogFly	Tracker0	60.0	absolute
#X	*Joystick0	0	0.0	0.0	1.0	1.0
#Y	*Joystick0	1	0.0	0.0	-1.0	1.0
#Z	*Joystick0	6	0.0	0.0	1.0	1.0
#RX	NULL		3	0.0	0.0	1.0	1.0
#RY	NULL		4	0.0	0.0	1.0	1.0
#RZ	*Joystick0	5	0.0	0.0	0.5	1.0
#RESET	NULL	0
#CLUTCH	NULL 0

# Using a joystick to emulate a Phantom for the
# nanoManipulator, the throttle maps to Z.
#vrpn_Tracker_AnalogFly	Phantom	60.0	absolute
#X	*Phantom	0	0.0	0.0	0.125	1.0
#Y	*Phantom	1	0.0	0.0  -0.125	1.0
#Z	*Phantom	6	0.0	0.0	0.25	1.0
#RX	NULL		3	0.0	0.0	1.0	1.0
#RY	NULL		4	0.0	0.0	1.0	1.0
#RZ	*Phantom	5	0.0	0.0	0.06	1.0
#RESET	NULL	0
#CLUTCH	NULL 0

# For DTU/MIC optical nanoHand stage motion, moving over full 300 micron range
# of motion, using the Logitech joystick for the analog
# server and the tracker_to_poser program.
#vrpn_Tracker_AnalogFly	Tracker0	60.0	absolute
#X	*Joystick0	0	-0.03	0.0	2.53	1.0
#Y	*Joystick0	1	-0.04	0.0	2.53	1.0
#Z	*Joystick0	6	-0.10	0.0	-1.75	1.0
#RX	NULL		3	0.0	0.0	1.0	1.0
#RY	NULL		4	0.0	0.0	1.0	1.0
#RZ	*Joystick0	5	0.0	0.0	0.5	1.0
#RESET	NULL	0
#CLUTCH	NULL 0

# To drive a Tektronix 4662 full range (Z, RZ ignored)
#vrpn_Tracker_AnalogFly	Tracker0	60.0	absolute
#X	*Joystick0	0	-1.0	0.0	0.19	1.0
#Y	*Joystick0	1	1.0	0.0	-0.13	1.0
#Z	*Joystick0	6	0.0	0.0	1.0	1.0
#RX	NULL		3	0.0	0.0	1.0	1.0
#RY	NULL		4	0.0	0.0	1.0	1.0
#RZ	*Joystick0	5	0.0	0.0	0.5	1.0
#RESET	NULL	0
#CLUTCH	NULL 0

# For UNC Mad City Labs stage motion, moving over full 100 micron range
# of motion, using the Microsoft FF joystick for the analog
# server and the tracker_to_poser program.
#vrpn_Tracker_AnalogFly	Tracker0	60.0	absolute
#X	*Joystick0	0	-1	0.0	50	1.0
#Y	*Joystick0	1	-1	0.0	50	1.0
#Z	*Joystick0	6	-1	0.0	50	1.0
#RX	NULL		3	0.0	0.0	1.0	1.0
#RY	NULL		4	0.0	0.0	1.0	1.0
#RZ	*Joystick0	5	0.0	0.0	0.5	1.0
#RESET	NULL	0
#CLUTCH	NULL 0

# For Artemis or Hercules (mad-city-labs) stages
# Maps 0-10 from the voltage into the range 0-100 microns.
#vrpn_Tracker_AnalogFly	StageTracker	60.0	absolute
#X	*MCLXYZIN	4	0	0.0	10	1.0
#Y	*MCLXYZIN	5	0	0.0	10	1.0
#Z	*MCLXYZIN	6	0	0.0	10	1.0
#RX	NULL		3	0.0	0.0	1.0	1.0
#RY	NULL		4	0.0	0.0	1.0	1.0
#RZ	NULL		5	0.0	0.0	1.0	1.0
#RESET	NULL	0
#CLUTCH	NULL 0

# For a 3DConnexion Traveler named device0
# You should scale the values for translation w.r.t.
# rotation to suit your preferences.
#vrpn_Tracker_AnalogFly	Tracker0	60.0	differential
#X	*device0	0	0.0	0.0	 2.0	1.0
#Y	*device0	1	0.0	0.0	-2.0	1.0
#Z	*device0	2	0.0	0.0	-2.0	1.0
#RX	*device0	3	0.0	0.0	-0.2	1.0
#RY	*device0	4	0.0	0.0	 0.2	1.0
#RZ	*device0	5	0.0	0.0	 0.2	1.0
#RESET	*device0	0
#CLUTCH	NULL 0

################################################################################
# XXX This device is superceded by the more-general vrpn_Tracker_AnalogFly.
# JoyFly Tracker. A vrpn_Tracker that translates the vrpn_Joystick into
# Walkthrough- convention tracker reports. This is part of a two-part setup
# that allows you to use a joystick as a flying device. First, a joystick
# device has to be created (named joybox in our example) that will produce
# the analog inputs that the JoyFly tracker uses to determine the transformation.
# Then, the JoyFly device needs to be started and will listen to the device
# and produce tracker reports. If these are both run on the same server, then
# the JoyFly needs to use the "server" connection to hear from the Joystick
# device, which is indicated by placing a '*' in front of the name of the
# joystick device that it is to use. If the joystick device is remote from
# this server, then the full name of it should be used (joystick@foo.cs.unc.edu).
# XXX This device is superceded by the more-general vrpn_Tracker_AnalogFly
# Arguments:
#	char	name_of_this_device[]
#	char	source_joystick_name[]  (Start with * for one sharing a connection)
#	char	joystick_configuration_file_name[]

#vrpn_JoyFly walk-joybox *joybox vrpn_Joyfly.cfg

################################################################################
# ButtonFly Tracker. This is a tracker that is intended to be used on top of
# a Global Haptics Orb or other buttond device to turn it into a moving or
# flying device.  It basically takes in button signals and puts out
# transformation matrices.
#   There are two kinds of Buttons: absolute ones and differential ones.  For
# absolute ones, pressing it causes the position or orientation associated with
# it to be stored directly into the transformation.  This enables the user to
# "teleport" to given locations by pressing buttons.  For differential ones,
# the position or orientation are treated as deltas and are used to create a
# "change" matrix that is applied once per interval, accumulating changes as
# it goes; this enables the user to "fly" along by holding a button down,
# for example.
#   Each button is associated with either a position (meters) or speed
# (meters/second) for absolute buttons; or an orientation (revolutions)
# or angular velocity (revolutions/second).
#   An analog channel can be associated with a scale function that scales the
# velocity or angular velocity terms uniformly.  The entry specifies an
# offset to be applied to the analog channel, a scale to be applied to it,
# and a power to which the result should be taken; the end result is used
# to scale all velocity or angular velocity terms.  This channel has no
# effect on the effects of absolute buttons.
#   The device will recenter (set itself to the identity transform) when the
# first connection is made to the server it is running on.
#   Note that you could have multiple of these devices running simultaneously,
# each with a different name and interaction metaphor. The user could then
# connect to their favorite one. Arguments:
#	char  name_of_this_device[]
#	float update_rate_to_send_tracker_reports
#	[one or more lines follow, each of one of two types
#	    (1)	char	[] = "absolute"
#		char	name_of_button_device[] (start with * for local)
#		int	which_button_on_device
#		float	X_to_translate_to
#		float	Y_to_translate_to
#		float	Z_to_translate_to
#		float	rotation_about_X
#		float	rotation_about_Y
#		float	rotation_about_Z
#	    (2)	char	[] = "differential"
#		char	name_of_button_device[] (start with * for local)
#		int	which_button_on_device
#		float	X_translation_meters_per_second
#		float	Y_translation_meters_per_second
#		float	Z_translation_meters_per_second
#		float	spin_about_X_revolutions_per_second
#		float	spin_about_Y_revolutions_per_second
#		float	spin_about_Z_revolutions_per_second
#	]
#	[An optional line describing an analog to scale the velocity
#		char	[] = "vel_scale"
#		char	name_of_button_device[] (start with * for local)
#		int	which_button_on_device
#		float	offset
#		float	scale
#		float	power
#	]
#	[An optional line describing an analog to scale the rotation
#		char	[] = "rot_scale"
#		char	name_of_button_device[] (start with * for local)
#		int	which_button_on_device
#		float	offset
#		float	scale
#		float	power
#	]
#	[one more line, consisting of the word "end"]
#   Note that the same button can cause more than one action to take place,
# and the same analog can cause scaling of both the velocity and rotation.

# This example for a Global Haptics Orb pushes the transformation away
# from the button that is pressed
# for all of the standard buttons.  It rotates around the Y axis when the
# rocker switch is rocked up and down.  It resets to the origin when one
# of the pushbuttons is pressed.  Both the velocity and angular velocity
# are controlled by the thumbwheel.

#vrpn_Tracker_ButtonFly	Tracker0	60.0
#differential	*Orb0	0	0 1 0	0 0 0
#differential	*Orb0	1	0.707 0.707 0	0 0 0
#differential	*Orb0	2	1 0 0	0 0 0
#differential	*Orb0	3	0.707 -0.707 0	0 0 0
#differential	*Orb0	4	0 -1 0	0 0 0
#differential	*Orb0	5	-0.707 -0.707 0	0 0 0
#differential	*Orb0	6	-1 0 0	0 0 0
#differential	*Orb0	7	-0.707 0.707 0	0 0 0
#differential	*Orb0	8	0 0.707 -0.707	0 0 0
#differential	*Orb0	9	0.577 0.577 -0.577	0 0 0
#differential	*Orb0	10	0.707 0 -0.707	0 0 0
#differential	*Orb0	11	0.577 -0.577 -0.577	0 0 0
#differential	*Orb0	12	0 -0.707 -0.707	0 0 0
#differential	*Orb0	13	-0.577 -0.577 -0.577	0 0 0
#differential	*Orb0	14	-0.707 0 -0.707	0 0 0
#differential	*Orb0	15	-0.577 0.577 -0.577	0 0 0
#differential	*Orb0	16	0 0.707 0.707	0 0 0
#differential	*Orb0	17	0.577 0.577 0.577	0 0 0
#differential	*Orb0	18	0.707 0 0.707	0 0 0
#differential	*Orb0	19	0.577 -0.577 0.577	0 0 0
#differential	*Orb0	20	0 -0.707 0.707	0 0 0
#differential	*Orb0	21	-0.577 -0.577 0.577	0 0 0
#differential	*Orb0	22	-0.707 0 0.707	0 0 0
#differential	*Orb0	23	-0.577 0.577 0.577	0 0 0
#differential	*Orb0	24	0 0 -1	0 0 0
#differential	*Orb0	25	0 0 1	0 0 0
#differential	*Orb0	28	0 0 0	0 -0.1 0
#differential	*Orb0	29	0 0 0	0 0.1 0
#absolute	*Orb0	27	0 0 0	0 0 0
#vel_scale	*Orb0	0	-1.0 0.5 1.0
#rot_scale	*Orb0	0	-1.0 0.5 1.0
#end

################################################################################
# 3Space Tracker. Runs a Polhemus 3Space (not Fastrak) tracker that is attached
# to a serial port on this machine.  Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device

#vrpn_Tracker_3Space	Tracker0	/dev/ttyS0	19200

################################################################################
# Logitech 3DMouse tracker attached to a serial port on this machine.
#  Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device
#	int	filtering_count (this parameter is optional)

#vrpn_Tracker_3DMouse	Tracker0	/dev/ttyS0	19200

################################################################################
#  NDI Polaris Spectra or Vectra, attached to a serial or USB port
# This server works with the NDI Polaris Spectra and Polaris Vectra
# trackers.  It doesn't work with the Optitrak or Aurora.  It only
# handles rigid bodies made from passive sphere markers, and does
# not yet support active led markers nor single "stray" passive
# spheres.
#
# Each vrpn "sensor" is a single rigid body (or "tool" in NDI
# terminology), which consists of 3 or more passive spheres in a
# particular geometric arrangement. In order to define a custom
# rigid body (one that didn't come from NDI), you must use the NDI
# Architect software. That software produces .rom files for each
# rigid body. This vrpn tracker class will load those files during
# initialization.
#
# Before configuring the vrpn server here, you should first run
# the NDI software to track the rigid bodies using the NDI's
# interactive GUI. Only after you have configured and tested the
# tracker and rigid bodies to your satisfaction, should you try
# this vrpn server.
#
# This currently only handles an IR strobe rate of 60Hz, not
# 20Hz or 30Hz.
#
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	    number of sensors (i.e. num of rigid bodies)
#
#   char    rigidBody 0's .rom filename
#   char    rigidBody 1's .rom filename
#   char    rigidBody 2's ...

# vrpn_Tracker_NDI_Polaris Tracker0 COM1 2
# hello.rom
# ../world.rom

################################################################################
# CerealBox dial/button/analog. Runs a BG Systems CerealBox device that attaches
# to a serial port on this machine. As of VRPN version 04.07, 19200 is the
# only supported baud rate. The driver has been tested on an LV824-F-8e device.
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device
#	int	number_of_buttons_to_read (starting from 0)
#	int	number_of_analogs_to_read
#	int	number_of_encoders_to_read

#vrpn_CerealBox	Cereal0	/dev/cua0	19200	8 8 8

################################################################################
# Magellan button/analog. Runs a Logitech Magellan device that attaches
# to a serial port on this machine. As of VRPN version 04.12, 9600 is the
# only supported baud rate.
#
# The Magellan is also known in some instances as the Magellan SpaceMouse,
# not to be confused with the 3DConnexion SpaceMouse (later version of the
# same product).
# 3DConnexion Magellan/SpaceMouse Plus XT Serial -
#	works with vrpn_Magellan without "altreset" for some.
#	requires "altreset" to avoid lots of beeping at startup for others.
#
# Note that if you want to use the Magellan as a tracking device, you will
# need to run a vrpn_Tracker_AnalogFly device that listens to its analog
# outputs and converts them into tracker reports
#
# John Stone added support for the SpaceBalls in version 06.03, an example
# startup is shown below.
#
# Julien Brisset discovered how to make this work with a slightly older version
# of the Magellan.  If the example Magellan line doesn't work, add 'altreset' to
# the line to use the alternative reset string for the device.
#
# If your Magellan is connected through a usb-serial cable on Mac OS X, use
# /dev/tty.usbserial, on Linux you may want to try /dev/ttyUSB0 instead.
#
# NOTE: You should NOT run the driver that comes with the Magellan, since the
# VRPN driver opens the serial port and communicates with the device directly.
# If the Magellan driver from the manufacturer is running, then VRPN may not
# be able to open the port.
#
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device
#	char	"altreset"   {Optional, for older Magellans}

#vrpn_Magellan	Magellan0	COM1	9600
#vrpn_Magellan	Magellan0	/dev/ttyS0	9600	altreset
#vrpn_Spaceball	Spaceball0	/dev/ttyS0	9600
#vrpn_Magellan	Magellan0	/dev/tty.usbserial	9600	altreset

################################################################################
# NRL Immersion Box dial/button/analog. Runs a Immersion Interface Box device
# attached to a serial port. As of March 28, 2000 code to read the analog and
# angle encoders has not been implemented.  Also, baud rate on many SGI's is
# limited to 38400, but I have run the ibox at 115200 on PCs.
#       char    name_of_this_device[]
#       char    name_of_serial_device[]
#       int     baud_rate_of_serial_device
#       int     number_of_buttons_to_read (i.e. 4 ==> 0,1,2,3)
#       int     number_of_analogs_to_read
#       int     number_of_encoders_to_read

#vrpn_ImmersionBox      ibox    /dev/ttyd2      38400   4 0 0
#vrpn_ImmersionBox      ibox    com1            115200  4 0 0

################################################################################
# Wands button/analog, driver from Brown University. Runs a Wanda device
# attached to a serial port.
#
# Arguments:
#       char    name_of_this_device[]
#       char    name_of_serial_port_to_use[]
#       int     baud_rate_of_serial_device
#	float   minimum_update_rate

#vrpn_Wanda      Wanda    /dev/ttyd2      1200   60.0
#vrpn_Wanda      Wanda    COM2      1200   60.0

################################################################################
# Radamec Serial Position Interface analog. Camera tracker that attaches
# to a serial port on this machine. Note that for normal operation, 38400 is the
# only supported baud rate.
#
# Note that if you want to use the Radamec SPI as a tracking device, you will
# need to run a vrpn_Tracker_AnalogFly device (of the absolute variety)
# that listens to its analog outputs and converts them into tracker reports.
#
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_port[]
#	int	baud_rate_of_serial_port

#vrpn_Radamec_SPI	Analog0	/dev/ttyS16	38400

################################################################################
# Zaber linear positioning element analog/out that attaches
# to a serial port on this machine.
#
# Note that if you want to use the Zaber as a tracking device, you will
# need to run a vrpn_Tracker_AnalogFly device (of the absolute variety)
# that listens to its analog outputs and converts them into tracker reports.
#
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_port[]

#vrpn_Zaber	Analog0	COM1

################################################################################
# Biosciences Tools temperature control unit, analog/out that attaches
# to a serial port on this machine.
#
# This instrument also has a button device that reports whether the
# temperature control is turned on.
#
# Analog channels: (read by client)
#	0	Reading from stage 1 in degrees Celcius
#	1	Reading from bath 1 in degrees Celcius
#	2	Reading external 1 or Setpoint for control in degrees Celcius
#	3	Reading from stage 2 in degrees Celcius
#	4	Reading from bath 2 in degrees Celcius
#	5	Reading external 2 or Setpoint for control in degrees Celcius
# Button channels: (read by client)
#	0	Temperature control is on or off
# Analog_Output channels: (set by client)
#	0	Reference temperature for channel 1
#	1	Reference temperature for channel 2
#	2	Turn temperature control on/off (0 = off, otherwise on)
#
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_port[]
#	float	Temperature to set for channel 1 in degrees Celcius
#	float	Temperature to set for channel 2 in degrees Celcius
#	int	Do we turn on temperature control (0 = no, 1 = yes)

#vrpn_BiosciencesTools	Analog0	COM1 37.0 37.0 0

################################################################################
# Omega temperature control unit, analog/out that attaches
# to a serial port on this machine.
#
# This instrument also has a button device that reports whether the
# temperature control is turned on.
#
# XXX Figure out the settings once the code has been finished.

#vrpn_OmegaTemerature	Analog0	COM1 XXX

################################################################################
# IDEA-drive linear positioning element analog that attaches
# to a serial port on this machine.
#
# Note that if you want to use the IDEA as a tracking device, you will
# need to run a vrpn_Tracker_AnalogFly device (of the absolute variety)
# that listens to its analog outputs and converts them into tracker reports.
#
# If the drive does not have a limit switch to calibrate against and you need to
# drive it to one rail to find a zero location, use a nonzero initial_move
# value to cause a move.  To keep it from getting stuck against that limit,
# change the fractional_c_a value to be less than one -- this will lower
# both the current and the acceleration/deceleration by this fraction for
# this initial move.  The location of the device is reset to 0 after the
# move is done.
#
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_port[]
#	int	run_speed_tics_sec
#	int	start_speed_tics_sec
#	int	end_speed_tics_sec
#	int	accel_rate_tics_sec_sec
#	int	decel_rate_tics_sec_sec
#	int	run_current
#	int	hold_current
#	int	accel_current
#	int	decel_current
#	int	delay
#	int	step
#	int	high_limit_index	(-1 for none)
#	int	low_limit_index		(-1 for none)
#	int	output_1_value		(0 for off, 1 for on, -1 for don't change)
#	int	output_2_value		(0 for off, 1 for on, -1 for don't change)
#	int	output_3_value		(0 for off, 1 for on, -1 for don't change)
#	int	output_4_value		(0 for off, 1 for on, -1 for don't change)
#	double	initial_move		(0 for no move)
#	double	fractional_c_a		(Fraction of full current and acceleration)
#	double	reset_location		(Where to set location on reset in full ticks)

#vrpn_IDEA	Analog0	COM1 3200 1200 2000 40000 100000 290 0 290 290 50 8 1 -1 0 0 0 0 0 1.0 -60.0
#vrpn_IDEA	Analog1	COM2 3200 1200 2000 40000 100000 290 0 290 290 50 8 1 -1 0 0 0 0 0 1.0 -60.0
#vrpn_IDEA	Analog2 COM3 3200 1200 2000 40000 100000 290 0 290 290 50 8 1 -1 0 0 0 0 0 1.0 -60.0
#vrpn_IDEA	Analog0	/dev/ttyUSB1 3200 1200 2000 40000 100000 290 0 290 290 50 8 -1 -1 0 0 0 0 10000 0.2 -60.0
#vrpn_IDEA	Analog1	/dev/ttyUSB2 3200 1200 2000 40000 100000 290 0 290 290 50 8 -1 -1 0 0 0 0 10000 0.2 -60.0
#vrpn_IDEA	Analog2	/dev/ttyUSB3 3200 1200 2000 40000 100000 290 0 290 290 50 8 -1 -1 0 0 0 0 10000 0.2 -60.0

################################################################################
# SGI Dial and Button box, raw interface. Runs a dial-and-button box from SGI,
# talking to it through the raw serial interface (not using the GL interface
# supplied by SGI). This allows the box to be opened even if there is nobody
# logged on at the console. Note that to use this on an SGI, you will need to
# configure the port as a serial device, not as a button device, to get it to
# run. Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	[list of buttons to treat as toggles]	int	button_to_toggle

#vrpn_raw_SGIBox	Sgibox0	/dev/ttyS0	0 1 2 3

################################################################################
# SGI Dial and Button box, cooked interface. Runs a dial-and-button box from SGI,
# talking to it through the GL interface supplied by SGI. Note that this can
# only be used on an SGI, and the serial port must be configured as a dial/button
# device and the dial/button server from SGI must be running to use it. Arguments:
#	char	name_of_this_device[]
#	[list of buttons to treat as toggles]	int	button_to_toggle

#vrpn_SGIBOX	Sgibox0	1 2

################################################################################
# UNC Python button device. UNC has developed a custom button input device, which
# is a 5-button controller that attaches to a parallel port and uses the sense
# lines to return the state of the buttons. This runs the device. Note that on
# Windows NT, you need to have installed the GiveIO driver for this code to
# work. It also works on Linux (no extra drivers needed), but on no other
# architecture. Arguments:
#	char	name_of_this_device[]
#	int	parallel_port_to_use_starting_with_1
#	int	hexadecimal_io_base_number (default address used if left off)

#vrpn_Button_Python	Button0	1

################################################################################
# UNC Joystick driver. UNC has developed a custom-build joybox, with 7 analog
# and 2 button inputs (two 3-axis joysticks and a slider, with a button on top
# of each joystick). This will drive one of these devices, which attaches to
# a serial port on this computer. I'm not sure what the baud rate should be;
# David Harrison might know.
# This driver can be used in conjunction with the JoyFly driver to produce a
# tracker that uses the joystick to fly around. Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device
#	float	minimum_update_rate_from_analogs_even_if_they_dont_move

#vrpn_Joystick	Joybox0	/dev/ttyd1	19200	10.0

################################################################################
# Linux Joystick. Interface to the Linux Joystick driver by Vojtech Pavlik
# included in several Linux distributions. The server code has been tested
# with Linux Joystick driver version 1.2.14. Yet, there is no way how to
# map a typical joystick's zillion buttons and axes on few buttons and axes
# really used. Unfortunately, even joysticks of the same kind can have
# different button mappings from one to another.
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_joystick_device[]

#vrpn_Joylin	Joylin0	/dev/input/js0

################################################################################
# Fakespace Pinch Glove. Drives a Fakespace Pinch Glove device connected to a
# serial port on this machine. This device has ten buttons-two hands and five
# fingers on each hand. Buttons 0-4 are fingers for the right hand-thumb first
# and pinkie last- while buttons 5-9 are for the left hand-thumb first. The
# Button is ON when it is touching another finger. Therefore there cannot
# be just one Button ON. Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device

#vrpn_Button_PinchGlove	PinchGlove0		COM1		9600

################################################################################
# Adrienne Electronics Corporation PCI time code driver.  The PCI-VITC board
# for which this driver was developed reads in VITC time codes from an input
# signal.  This will drive one of these devices.
# Arguments:
# char name_of_this_device[]

#vrpn_TimeCode_Generator	TimeGen0

################################################################################
# 5DT glove (5 sensors plus optional tilt sensors).
# Drive a 5dt glove connected on a serial Port. This device uses
# optical fiber to get the finger position.
#
# See also vrpn_5DT16 (16-sensor serial) and vrpn_Analog_5dtUSB (5 or 14-sensor
# "Ultra" USB/wireless)
#
# 2 modes are driven: the first one let the driver get data from the glove
# when requested (we advise this mode). The second one makes the glove send
# data continuously. This mode may saturate the input buffer.
#
# The manual states that there will be 9 bytes per report, but one group
# has found that they get an extra one: 0x55 at the end of each report.
# So, you can choose whether to use 9 (the default) or 10 now.
# Gesture management is not implemented yet nor the mouse emulation mode
#
# The standard baud rate for the "wired" glove is 19200. For a "wireless"
# glove (which is send-only), even if directly connected, use baud rate
# 9600. The driver detects this and will adjust its behavior accordingly
# (forcing on continuous mode and 10-bytes-per-report, ignoring the settings
# you specify here).  If you aren't  sure what kind of glove you have, use the
# Glove Manager app in
# "5DT Data Glove Series: Full Package for Windows 95/98/NT/2000" downloaded from
# http://5dt.com/downloads.html and try to connect, it will tell you.
# Their Glove Manager worked for me on Linux 64-bit with WINE, and is probably the
# easiest way to find out this info if you don't know it. (Or, just try 9600 if
# 19200 doesn't work.)
#
# Reports the digit bend values in order, channels 1-5, in the range 0.0-1.0,
# and the tilt sensors in channels 6 and 7 in the range 0 to 180, if available
#
# arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device
#	int	mode_of_data_reporting (1 = on request, 2 = continuously)
#	int	ten_bytes_per_report (0 = no, use 9; 1 = yes)

#vrpn_5dt	glove_5dt	/dev/ttyS0	19200	1 0
#vrpn_5dt	glove_5dt	COM1	19200	1 0
#vrpn_5dt   glove_5dt_wireless /dev/ttyS1 9600 2 1

################################################################################
# NRL Serial Mouse. A device made by wiring buttons in parallel with the buttons
# on a serial mouse.  Both mousesystems or microsoft mouse protocols are
# supported.  Note that the server code makes the connection at the standard
# 1200 baud.  The mouse can be plugged into any serial port -- this driver goes
# directly through the raw port and does not use the built-in mouse drivers.
# NOTE: The middle button on the 3button type is toggled by moving the mouse
# on a surface while not toggling the other two buttons, strange as this may
# seem.  The motion of the mouse is not reported, only the buttons.

#vrpn_Button_SerialMouse	Button0 /dev/ttyd1 mousesystems
#vrpn_Button_SerialMouse	Button0 COM1 mousesystems
#vrpn_Button_SerialMouse	Button0 COM1 3button
# For a Linux box with a mouse on port 0
#vrpn_Button_SerialMouse	Button0 /dev/ttyS0 3button
# For a mac with a Keyspan 4-port serial-to-USB converter
#vrpn_Button_SerialMouse	Button0 /dev/tty.USA49W3b12P1.1 3button

################################################################################
# ReliaSolve Streaming Arduino.
#       char    name_of_this_device[]
#       char    name_of_serial_device[]
#       int     number_of_analogs_to_read

#vrpn_Streaming_Arduino      sa0    /dev/ttyd2  4
#vrpn_Streaming_Arduino      sa0    COM5  4

################################################################################
# NRL TNG3.  (Totally Neat Gadget) A device made by mindtel, available from
# pulsar.org.  Powered off the serial port control lines, the TNG3 has 8 digital
# and 8 analog inputs.  Analog resolution is 8 bits. Baud rate fixed internally
# at 19200.
#       char    name_of_this_device[]
#       char    name_of_serial_device[]
#       int     number_of_buttons_to_read (i.e. 8 ==> 0,1,2,3,4,5,6,7)
#       int     number_of_analogs_to_read

#vrpn_Tng3      tng3name    /dev/ttyd2  4 0
#vrpn_Tng3      tng3name    com1        8 8
#vrpn_Tng3      tng3name    com1        1 1

################################################################################
# Microsoft DirectX compatible force-feedback joystick (or non-force-feedback
# joystick).
#       char    name_of_this_device[]
#       int     number of times per second to read from the device
#       int     number of times per second to update force (0 for non-force device)

#vrpn_DirectXFFJoystick	Joystick0	60	200
#vrpn_DirectXFFJoystick	Joystick0	60	0


################################################################################
# Microsoft DirectX compatible rumble-pad (e.g. Wingman)
#       char    name_of_this_device[]

#vrpn_DirectXRumblePad		RumblePad0

################################################################################
# Microsoft XInput compatible controller (e.g. Xbox 360 gamepad)
#	char	name_of_this_device[]
#	int	userIndex (0 for "Player 1", 1 for "Player 2", etc.)

#vrpn_XInputGamepad		XInput0 0


################################################################################
# Manager for joysticks under windows using standard win32 calls.
# for force feedback support, see DirectX joystick above
#
# Arguments:
#	char	name_of_this_device[]
#	int	joystick Id
#           (1 for first joystick JOYSTICKID1 or 2 for second JOYSTICKID2 only)
# 	int  number of times per second to read from the device
# 	int  readmode : 0 = raw data;
#			1 = 0,1 normalized data;
#			2=-1,1 normalized data
# 	int  percentage (0 to 100) of deadzone (used mode 1 and 2 only)

#vrpn_Joywin32 joyWin32 1 60 2 35

################################################################################
# Global Haptics GeoOrb serial-line device that contains a number of buttons,
# a thumbwheel, and a trackball.  For current devices, only 19200 baud works.
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device

#vrpn_GlobalHapticsOrb	Orb0	COM1	19200

################################################################################
# SensAble Technologies Phantom force-feedback device opened using the
# GHOST software developer's kit.  For Phantom Desktop systems, you don't
# need to have the user establish the reset position.  For the Premium models,
# you do.
# Arguments:
#	char	name_of_this_device[]
#	int	establish_reset_position	(0 or 1)
#	float	rate_to_send_tracker_reports
#	char	Name of the Phantom in the configuration control panel

#vrpn_Phantom	Phantom	0	60.0	Default PHANToM

##############################################################################
# Virtual Presence Joystick tracker device. (http://www.vrweb.com)
# Use this driver to read the button states,
# use Flock-of-Birds driver for the position/orientation state
#
# Arguments:
#  char  name_of_this_device[]
#  char  name_of_serial_device[]
#  int   baud_rate_of_serial_device

#vrpn_VPJoystick VPJoystick0 /dev/ttyS0 9600

################################################################################
# Advanced Realtime Tracking GmbH (http://www.ar-tracking.de) DTrack client
#
# creates as many vrpn_Tracker as there are bodies or Flysticks, starting with the bodies
# creates 2 analogs per Flystick
# creates 8 buttons per Flystick
#
# NOTE: when using DTrack's older output format for Flystick data ('6df'), the numbering
#       of Flystick buttons differs from DTrack documentation (for compatibility with
#       older vrpn releases)
#
# Arguments:
#  char  name_of_this_device[]
#  int   udp_port                               (DTrack sends data to this UDP port)
#
# Optional arguments:
#  float time_to_reach_joy                      (in seconds; see below)
#  int   number_of_bodies, number_of_flysticks  (fixed numbers of bodies and Flysticks)
#  int   renumbered_ids[]                       (vrpn_Tracker IDs of bodies and Flysticks)
#  char  "3d"                                   (activates 3dof marker output if available;
#                                                always last argument if "-" is not present)
#  char  "-"                                    (activates tracing; always last argument)
#
# NOTE: time_to_reach_joy is the time needed to reach the maximum value (1.0 or -1.0) of the
#       joystick of older 'Flystick' devices when the corresponding button is pressed
#       (one of the last buttons amongst the 8); not necessary for newer 'Flystick2' devices
#       with its analog joystick
#
# NOTE: if fixed numbers of bodies and Flysticks should be used, both arguments
#       number_of_bodies and number_of_flysticks have to be set
#
# NOTE: renumbering of tracker IDs is only possible, if fixed numbers of bodies and
#       Flysticks are set; there has to be an argument present for each body/Flystick

#vrpn_Tracker_DTrack DTrack  5000
#vrpn_Tracker_DTrack DTrack  5000  -
#vrpn_Tracker_DTrack DTrack  5000  3d
#vrpn_Tracker_DTrack DTrack  5000  3d  -
#vrpn_Tracker_DTrack DTrack  5000  0.5
#vrpn_Tracker_DTrack DTrack  5000  0.5  2 2
#vrpn_Tracker_DTrack DTrack  5000  0.5  2 2  2 1 0 3
#vrpn_Tracker_DTrack DTrack  5000  0.5  2 2  2 1 0 3  3d  -

################################################################################
# National Instruments Analog Output server.  This will open the board whose
# name is specified, configure the number of channels specified, and set the
# polarity and maximum voltage range at which to drive the channels.
#
# XXX This server is deprecated, please use the vrpn_National_Instruments
# server listed below.
#
# Arguments:
#  char  vrpn_name_for_this_device[]
#  char  name_of_NI_board[]
#  int   number_of_channels
#  int   polarity : 0 = unipolar, 1 = bipolar
#  float min_voltage
#  float max_voltage

#vrpn_NI_Analog_Output	Analog_XY	DAQCard-6036E	2   0	-10.0 10.0
#vrpn_NI_Analog_Output	Analog_ZTweeze	DAQCard-6036E	2   0	-10.0 10.0
#vrpn_NI_Analog_Output	Analog_XYZ	PCI-6733	3   0	-10.0 10.0

################################################################################
# National Instruments A/D, D/A Analog and Analog Output server.  This will open
# the board whose name is specified, configure the number of channels specified,
# and set the polarity and maximum voltage range at which to read and
# drive the channels.
##
# Arguments:
#  char  vrpn_name_for_this_device[]
#  char  name_of_NationalInstruments_board[]
#  int   number_of_input_channels (can be zero)
#  float mininum_delay_between_Analog_Reports (zero for fastest)
#  int   input_polarity : 0 = unipolar, 1 = bipolar
#  int   input_mode : 0 = differential, 1 = ref single-end, 2 = non-ref SE
#  int   input_range : 5 = 5v, 10 = 10v, 20 = 20v
#  int   input_drive_ais : 0 = no, 1 = yes
#  int   input_gain
#  int   number_of_output_channels (can be zero)
#  int   output_polarity : 0 = unipolar, 1 = bipolar
#  float min_out_voltage (used to guard against overdriving devices)
#  float max_out_voltage (used to guard against overdriving devices)

# Input example
#vrpn_National_Instruments MCLXYZIN PCI-6052E 7 0 0 0 10 0 1 0 0 -10.0 10.0
# Output examples
#vrpn_National_Instruments MCLXYZOUT PCI-6733 0 0 0 0 10 0 1 3 0 0.0 10.0
#vrpn_National_Instruments Analog_XY DAQCard-6036E 0 0 0 0 10 0 1 2 1 -10.0 10.0

################################################################################
# Analog Poser. This is a poser that is intended to be used on top of
# an analog output (perhaps a National Instruments board), whose outputs
# directly drive the position of some actuated stage.  It could be used on top
# of any analog output device, in fact.  This device basically takes in poses
# and puts out analog outputs.
#   One analog channel is associated with each axis (X, Y, Z) and rotation about
# each axis (RX, RY, RZ). For each axis, the position (meters) is converted into
# a voltage; the orientation is mapped from a quaternion into Euler angles and
# each of the Euler angles is converted into a voltage (XXX Orientation is not yet
# implemented; the RX,RY, and RZ values must be specified but they are not used).
# XXX Velocity and orientation velocity are not yet supported.
#   Any axis can be disabled by setting the name of its associated device to the
# string "NULL".
#
# Arguments:
#	char  vrpn_name_for_this_device[]
#	int	send_tracker_reports
#	[six lines follow, one for X Y Z RX RY RZ, each with:
#		char	axis_name[]			(X Y Z RX RY RZ in that order)
#		char  vrpn_name_of_the_analog_output_to_use[]
#			(Preface with a * if it uses the same connection)
#		int	channel_of_analog_output_device (First channel is channel 0)
#		float offset
#		float	scale
#		float min_value of workspace
#		float max_value of workspace
#	]

#vrpn_Poser_Analog	Poser0	1
#X	*Analog_XY	0	0.0	1.0	-10	10
#Y	*Analog_XY	1	0.0	1.0	-10	10
#Z	*Analog_ZTweeze	0	0.0	1.0	-10	10
#RX	NULL	0	0.0	1.0	-10	10
#RY	NULL	0	0.0	1.0	-10	10
#RZ	NULL	0	0.0	1.0	-10	10

# Poser to drive Mad City Labs stage from an input value of
# 0 to 100 microns to an output (through a National Instruments
# D/A card) of 0-10 volts.
#vrpn_Poser_Analog	Poser0	1
#X	*MCLXYZOUT	0	0.0	0.1	0	100
#Y	*MCLXYZOUT	1	0.0	0.1	0	100
#Z	*MCLXYZOUT	2	0.0	0.1	0	100
#RX	NULL	0	0.0	1.0	-10	10
#RY	NULL	0	0.0	1.0	-10	10
#RZ	NULL	0	0.0	1.0	-10	10

################################################################################
# Nikon microscope connected to PC via serial port.  Currently only controls
# the focus of the microscope using an analogout and reads the focus position
# using an analog.
#
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]

#vrpn_nikon_controls	nikon	COM1

################################################################################
# Tektronix 4662 plotter.  Attaches to a serial port.  Acts as both a poser and
# a tracker.  Reports positions 4x per second plus when a move command completes.
# Multiple move commands issued before they complete will result in only the last
# one being executed.
#
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device

#vrpn_Tek4662	Tek4662	COM1	1200

###############################################################################
# keyboard and mouse button is a tracker with button system
# XXX These have been removed and replaced with vrpn_Mouse
# and vrpn_Keyboard.  Use the clutch option on vrpn_AnalogFly to
# replicate the mouse behavior.  The vrpn_Keyboard does not
# enable key mapping, just sends all of the keys' scancodes
# through.

################################################################################
# US Digital A2 Absolute Encoder Analog Input server.  This will open the COM
# port specified, configure the number of channels specified, and report
# Absolute Encoder values in tenths of a degree from 0 to 3599.
#
# Arguments:
#	char	name_of_this_device[]
#       int     COM_port.  If 0, search for correct COM port.
#       int     number_of_channels
#	int	0 to report always, 1 to report on change only (optional, default=0)

#vrpn_Analog_USDigital_A2	Analog0 1	2

################################################################################
#      This is a driver for National Instruments DAQCard-
# DIO-24, a PCMCIA card, which provides 24-bit digital I/O.
#
# Arguments:
#	char	name_of_this_device[]
#       int     number_of_channls to read: 1-24 (optional.  default=24).

#vrpn_Button_NI_DIO24	Button0	1

##############################################################################
# PhaseSpace Impulse system.  This device type is not compiled by default, since
# it uses a proprietary library.  However, you can get it to compile by 
# defining VRPN_INCLUDE_PHASESPACE and including the appropriate libraries
# and headers when compiling (See vrpn_Configure.h).
# 
# Arguments:
#        char	tracker_name[]   # Tracker0, Tracker1, ... etc
#        [Additional lines specifying tracker configuration]
# 
# The section following the Tracker declaration is a tag delimited set of
# lines which specify system configuration and vrpn sensors.  The section begins
# with an <owl> tag and ends with a </owl> tag.  Each tag must be on a separate
# line. (see below)
# 
# Each line in the specification section is a white-space separated set of
# key-value pairs.  At most one sensor is defined per line.  The sensor and type
# keys are mandatory.  Other keys are are required based on the type.
#
# Comments can be embedded with the '#' character.
#
# Example:
# 
#       vrpn_Tracker_PhaseSpace Tracker0 
#       <owl>
#       device="192.168.1.1"
#       frequency=960
#       slave=0
#       drop_frames=0
#       scale=0.001
#       debug=0
#
#       sensor=0 type=point tracker=0 led=0  # this is a comment
#       sensor=1 type=point tracker=0 led=1  # map sensor 1 to led 1 on tracker 0
#
#       sensor=2 type=rigid_body tracker=1 # designate tracker 1 as a rigid body on sensor 2
#       sensor=3 type=point tracker=1 led=2 pos=0,0,0      # add led 2 to rigid body on tracker 1
#       sensor=4 type=point tracker=1 led=3 pos=100,0,0    # add led 3 to rigid body on tracker 1
#       sensor=5 type=point tracker=1 led=4 pos=0,100,0    # add led 4 to rigid body on tracker 1
#       sensor=6 type=point tracker=1 led=5 pos=0,0,100    # add led 5 to rigid body on tracker 1
#       </owl>
#
# Key Definitions
# ======================
#
# device
#    A string specifying the IP address of the Impulse server to connect to. 
#
# frequency
#    A floating-point number specifying the system streaming frequency.
#    Usually 480 or 960.
#
# slave
#    An integer specifying whether to enable slave mode.
#    Set to 0 to disable, 1 to enable. If slave mode is enabled,  unspecified
#    markers are assigned an arbitrary sensor number.
#
# drop_frames
#    An integer. Set to zero to disable.  Specifying 1 for drop_frames will
#    cause the server to drop frames in order to get the most recent data on
#    every run through the mainloop. This may be desirable for most VR
#    applications and for slower machines. 
#
# debug
#    An integer.  Zero to disable.  Specifying 1 for debug will cause the server
#    to print out verbose debugging output.
#
# scale
#    The floating-point factor to scale incoming positional data by.  The default
#    is 0.001.
#
# sensor
#    The vrpn sensor number.
#
# type
#    A string which specifies what type the sensor is. Required if sensor is
#    specified.  The following types are supported: 
#        point
#        rigid
#        rigid_body (deprecated)
#
# tracker
#    An integer which specifies The Impulse tracker id of an led or rigid body.
#    Required if type is "point" or "rigid".
#
# led
#    An integer which specifies the led id of a sensor.
#    Required if type is "point".
#    
# pos
#    An optional comma-separated list of three floating-point numbers specifying
#    the 3D position of a marker on a rigid body.  No spaces.  Valid if type is
#    "point".  Specifying positions is only valid if the tracker number is set
#    to a rigid body.  The units MUST be in millimeters, regardless of scale
#    setting.
# 
# init
#    An optional comma-separated list of four floating-point numbers specifying
#    kalman parameters for a rigid body.  Valid if type is "rigid_body".
#
#
# For support, questions, comments, or bug reports please send emails 
# to:  support@phasespace.com
# 
#vrpn_Tracker_PhaseSpace Tracker0 
#<owl>
#device="192.168.1.230"
#frequency=480
#slave=0
#drop_frames=0
#scale=0.001
#sensor=0 type=point led=0
#sensor=1 type=point led=1
#sensor=2 type=point led=2
#sensor=3 type=point led=3
#sensor=4 type=point led=4
#sensor=5 type=point led=5
#sensor=6 type=point led=6
#sensor=7 type=point led=7
#</owl>

################################################################################
# Generic Auxiliary Logger. This is a server that will listen for requests to
# produce additional log files and the name of the connection it should make the
# log files for.  It can only have one set of such logs open (can be more than
# one log but all for the same connection).  There are two arguments:
#	char	name_of_this_device[]
#	char	name_of_connection_to_log

#vrpn_Auxiliary_Logger_Server_Generic Logger0 localhost

################################################################################
# Imager Stream Buffer. This is a server that will listen for requests to
# produce additional log files and the name of the connection it should make the
# log files for.  It can only have one set of such logs open (can be more than
# one log but all for the same connection).  The "local" log files are with
# respect to the machine where this server is running, and the "remote" ones
# are with respect to the vrpn_Imager_Server it has connected to (which may
# be on yet a third machine compared to the client machine).
# There are two arguments:
#	char	name_of_this_device[]
#	char	name_of_imager_server_to_log

#vrpn_Imager_Stream_Buffer ImageStream0 TestImage@localhost

################################################################################
# controllers from Futaba.  There is one device we have
# drivers for.  The only argument is the name of the device to open.
#
# For Interlink Elite:
#	Analog channel assignments:
# 0=rudder (left joy X)
# 1=throttle (left joy Y)
# 2=aileron (right joy X)
# 3=elevator (right joy Y)
# 4=Ch6 Flaps Gain
#	Button number assignments:
# 0=Ch5 fwd
# 1=Ch7 fwd
# 2=reset
# 3=Ch8 down
# 4=Ch8 up
# 5=<none>
# 6=menu/select
# 7=cancel
# Next eight are for the trim buttons
# 8=aileron right
# 9=aileron left
# 10=elevator up
# 11=elevator down
# 12=rudder right
# 13=rudder left
# 14=throttle up
# 15=throttle down
# Next two are options button
# 16=up
# 17=down
#
# There is one argument:
#	char	name_of_this_device[]

#vrpn_Futaba_InterLink_Elite futaba0

################################################################################
# controllers from Griffin Technology.  There is one device we have
# drivers for.  The only argument is the name of the device to open.
#
# For PowerMate:
#	Analog channel assignments:
# none
#	Button number assignments:
# 0=only button
#	Dial assignments:
# 0=only dial
#
# There is one argument:
#	char	name_of_this_device[]

#vrpn_Griffin_PowerMate griffin0

################################################################################
# controllers from Retrolink.  There is one device we have
# drivers for.  The only argument is the name of the device to open.
#
# For GameCube:
#	Analog channel assignments:
# 0=Left joystick X axis; -1 = left, 1 = right
# 1=Left joystick Y axis; -1 = up, 1 = down
# 2=Right joystick X axis; -1 = left, 1 = right
# 3=Right joystick Y axis; -1 = up, 1 = down
# 4=Left rocker switch angle in degrees (-1 if nothing is pressed)
#	Button number assignments:
# 0=Y
# 1=X
# 2=A
# 3=B
# 4=left trigger
# 5=right trigger
# 6=Z
# 7=Start/pause
# Buttons 8-11 are duplicate mappings for the rocker-switch; both
# these and the analog angle in degrees will change as they are pressed
# 8 = up
# 9 = right
# 10 = down
# 11 = left
#
# For Genesis:
#	Analog channel assignments:
# 0=Rocker switch angle in degrees (-1 if nothing is pressed)
#	Button number assignments:
# 0=A
# 1=B
# 2=C
# 3=X
# 4=Y
# 5=Z
# 6=Mode
# 7=Start
# Buttons 8-11 are duplicate mappings for the rocker-switch; both
# these and the analog angle in degrees will change as they are pressed
# 8 = up
# 9 = right
# 10 = down
# 11 = left
#
# There is one argument:
#	char	name_of_this_device[]

# vrpn_Retrolink_GameCube retrolink0
# vrpn_Retrolink_Genesis retrolink0

################################################################################
# Controllers from Contour Design.  There are two devices we have
# drivers for.  The only argument is the name of the device to open.
#
# Dial: Moves in 0.1-revolution steps.
#
# Analogs:
#  analog[0] is the shuttle, which goes from -1 to 1
#  analog[1] integrates the dial, with 1 meaning a full revolution
#
# Buttons on the ShuttlePROv2:
#  Top row, left to right: buttons 0-3
#  Second row: Buttons 4-8
#  Four grey buttons below, left to right (two rows): 9-10, 11-12
#  Black buttons, left to right: 13-14
#
# For ShuttleXpress and ShuttlePROv2:
#
# There is one argument:
#	char	name_of_this_device[]

#vrpn_Contour_ShuttleXpress contour0
#vrpn_Contour_ShuttlePROv2 contour0

################################################################################
# controllers from Microsoft. The devices we have drivers for are listed below.
# The only argument is the name of the device to open.
#
# For SideWinder Precision 2 joystick
#	Analog channel assignments:
# 0=joystick X
# 1=joystick Y
# 2=Z rotate
# 3=slider
# 4=Point of View Hat heading (-1=nothing, 0=North, 45=Northeast, etc.)
#	Button number assignments
# 0=1
# 1=2
# 2=3
# 3=4
# 4=5
# 5=6
# 6=7
# 7=8
# Next four are point of view hat buttons
# 8=Up
# 9=Right
# 10=Down
# 11=Left
#
# For SideWinder joystick
#	Analog channel assignments:
# 0=joystick X
# 1=joystick Y
# 2=slider
#	Button number assignments
# 0=1
# 1=2
# 2=3
# 3=4
# 4=5
# 5=6
# 6=7
# 7=8
#
# For Xbox Controller S:
# Requires USB cable and special driver.
#	Analog channel assignments:
# 0=left joystick X
# 1=left joystick Y
# 2=right joystick X
# 3=right joystick Y
# 4=Point of View Hat heading (-1=nothing, 0=North, 45=Northeast, etc.)
#	Button number assignments
# 0=A
# 1=B
# 2=X
# 3=Y
# 4=Black
# 5=White
# 6=Start
# 7=Back
# 8=left joystick
# 9=right joytick
# 10=left trigger
# 11=right trigger
# Next four are point of view hat buttons
# 12=Up
# 13=Right
# 14=Down
# 15=Left
#
# For Xbox 360 Controller:
#	Analog channel assignments:
# 0=left joystick X
# 1=left joystick Y
# 2=right joystick X
# 3=right joystick Y
# 4=triggers (left goes positive, right goes negative)
# 5=Point of View Hat heading (-1=nothing, 0=North, 45=Northeast, etc.)
#	Button number assignments
# 0=A
# 1=B
# 2=X
# 3=Y
# 4=left bump
# 5=right bump
# 6=Back
# 7=Start
# 8=left joystick
# 9=right joytick
# Next four are point of view hat buttons
# 10=Up
# 11=Right
# 12=Down
# 13=Left
#
# There is one argument:
#	char	name_of_this_device[]

#vrpn_Microsoft_SideWinder_Precision_2 microsoft0
#vrpn_Microsoft_SideWinder microsoft0
#vrpn_Microsoft_Controller_Raw_Xbox_S microsoft0
#vrpn_Microsoft_Controller_Raw_Xbox_360 microsoft0
#vrpn_Microsoft_Controller_Raw_Xbox_360_Wireless microsoft0
#vrpn_Afterglow_Ax1_For_Xbox_360 microsoft0

################################################################################
# X-Keys devices from P.I. Engineering.  There are several devices we have
# drivers for.  The only argument is the name of the device to open.  The Pro
# and Joystick models have not been tested.  The XK3 is a 3-button foot pedal.
#
# There is one argument:
#	char	name_of_this_device[]

#vrpn_Xkeys_Desktop xkeys0
#vrpn_Xkeys_Pro xkeys0
#vrpn_Xkeys_Joystick xkeys0
#vrpn_Xkeys_Joystick12 xkeys0
#vrpn_Xkeys_Jog_And_Shuttle xkeys0
#vrpn_Xkeys_Jog_And_Shuttle12 xkeys0
#vrpn_Xkeys_Jog_And_Shuttle68 xkeys0
#vrpn_Xkeys_XK3 xkeys0

################################################################################
# controllers from Logitech other than 3Dconnexion which is listed separately.
# The devices we have drivers for are listed below.
# The only argument is the name of the device to open.
#
# For Extreme 3D Pro joystick
#	Analog channel assignments:
# 0=joystick X
# 1=joystick Y
# 2=Z rotate
# 3=slider
# 4=Point of View Hat heading (-1=nothing, 0=North, 45=Northeast, etc.)
#	Button number assignments
# 0=1
# 1=2
# 2=3
# 3=4
# 4=5
# 5=6
# 6=7
# 7=8
# 8=9
# 9=10
# 10=11
# 11=12
# Next four are point of view hat buttons
# 12=Up
# 13=Right
# 14=Down
# 15=Left
#
# There is one argument:
#	char	name_of_this_device[]

#vrpn_Logitech_Extreme_3D_Pro logitech0

################################################################################
# controllers from Saitek.
# The devices we have drivers for are listed below.
# The only argument is the name of the device to open.
#
# For ST290 Pro joystick
#	Analog channel assignments:
# 0=joystick X
# 1=joystick Y
# 2=Z rotate
# 3=slider
# 4=Point of View Hat heading (-1=nothing, 0=North, 45=Northeast, etc.)
#	Button number assignments
# 0=1
# 1=2
# 2=3
# 3=4
# 4=5
# 5=6
# 6=7
# Next four are point of view hat buttons
# 7=Up
# 8=Right
# 9=Down
# 10=Left
#
# There is one argument:
#	char	name_of_this_device[]

#vrpn_Saitek_ST290_Pro saitek0

################################################################################
# controllers from CH products.
# The devices we have drivers for are listed below.
# The only argument is the name of the device to open.
#
# For Fighterstick USB joystick
#       Analog channel assignments:
# 0=joystick X
# 1=joystick Y
# 2=throttle wheel
# 3=Point of View Hat heading (buttons 4-7: -1=nothing, 0=North, 45=Northeast, etc.)
# 4=Hat heading (buttons 8-11: -1=nothing, 0=North, 90=East, etc.)
# 5=Hat heading (buttons 12-15: -1=nothing, 0=North, 90=East, etc.)
# 6=Mode (buttons 2, 16-18): 0=unknown, 1=red, 2=yellow, 3=green)
# 7=Hat heading (buttons 20-23: -1=nothing, 0=North, 90=East, etc.)
#
#       Button number assignments
# 0=trigger
# 1=top red button
# 2=red button using index finger (see 16, 17, & 18)
# 3=pinky red button
# Next four are on 8-way POV hat: upper right on top
# 4=up
# 5=right
# 6=down
# 7=left
# Next four are on 4-way hat #2: lower right on top
# 8=up
# 9=right
# 10=down
# 11=left
# Next four are on 4-way hat #1: left on top
# 12=up
# 13=right
# 14=down
# 15=left
# Next three are modes triggered by button 2.
# Mode LEDs show the color listed below when pressed, but releasing with advance the color to the next in the series.
# These "buttons" are all released when unknown. Once the mode is known, one button will always be considered pressed.
# 16=green
# 17=red
# 18=yellow
# 19=
# Next four are on 4-way hat #3: thumb
# 20=Up
# 21=Right
# 22=Down
# 23=Left
#
# There is one argument:
#       char    name_of_this_device[]

#vrpn_CHProducts_Fighterstick_USB chproducts0

################################################################################
# Space Navigator, Space Traveler, and Space Mouse devices from 3DConnexion.
# 3Dconnexion is actually made by Logitech.
# Not to be confused with the Magellan Space Mouse, for which there is
# a Magellan driver.
# The only argument is the name of the device to open.
#
# There is one argument:
#	char	name_of_this_device[]
#
# For the SpaceMouse Pro:
#	Analog channel assignments:
# 0=x
# 1=y
# 2=z
# 3=pitch
# 4=roll
# 5=yaw
#	Button number assignments:
# (the ones similar to <x> have a graphic on the button and are referred to the text enclosed text in the help)
# 0=Menu
# 1=Fit
# 2=<T>
# 4=<R>
# 5=<F>
# 8=<Roll+>
# 12=1
# 13=2
# 14=3
# 15=4
# 22=Esc
# 23=Alt
# 24=Shift
# 25=Ctrl
# 26=<Rot>
#
# On Linux, make sure the HID and evdev drivers are running so that these
# devices will be recognized:
#  Start a separate Root shell:
#  cd .../vrpn/server_src/pc_linux
#  lsmod
#  modprobe evdev
#  modprobe hid
#  lsmod
#  (check that evdev and hid are running)
# On RedHat Linux, you need the have libusb1-devel installed and configure
#  the system for VRPN_USE_LOCAL_HIDAPI to get these to work.

#vrpn_3DConnexion_Navigator device0
#vrpn_3DConnexion_Navigator_for_Notebooks device0
#vrpn_3DConnexion_Traveler device0
#vrpn_3DConnexion_SpaceMouse device0
#vrpn_3DConnexion_SpaceMousePro device0
#vrpn_3DConnexion_SpaceMouseCompact device0
#vrpn_3DConnexion_SpaceMouseWireless device0
#vrpn_3DConnexion_SpaceMouseProWireless device0
#vrpn_3DConnexion_SpaceExplorer device0
#vrpn_3DConnexion_SpaceBall5000 device0
#vrpn_3DConnexion_SpacePilot spacepilot
#vrpn_3DConnexion_SpacePilotPro spacepilotpro

################################################################################
# Open the mouse as an analog and button devices.  There is an implementation
# under Windows and another under Linux (using GPM).  There are two analog
# channels, reporting in the range [0..1] as the mouse moves across the screen.
# There are 3 button channels: left, middle, right.
#
# There is one argument:
#	char	name_of_this_device[]

#vrpn_Mouse	Mouse0

################################################################################
# Open the keyboard as a button device.  There is an implementation
# under Windows.  There are 256 buttons, and they are triggered according
# to the scan code that they represent.
#
# There is one argument:
#	char	name_of_this_device[]

#vrpn_Keyboard	Keyboard0

################################################################################
# WARNING : LINUX ONLY !
# Open the /dev/input devices and treat them as mouse events
# There is as many as available channel (kernel 2.6.38 : 10 channels)
#
# There is three argument:
#	char	name_of_this_device[]
#	char	"name of the hardware device"
#	char	type of the device (must be one of "keyboard", "absolute" and "relative"
#	int	in case of keyboard : the total number of keys ; in case of absolute mouse : size of the window (ie. to normalize the result)
# The "name of the hardware device" is the Name entry of the device
# from /proc/bus/input/devices
# Due to hardware access through /dev/input/*, there is no notion of window.
# Thus, you must specify the window size. If '-1' is provided, then, this device
# only provide relative displacement of the channel
#
# Keyboard are standard keyboard (ie : the one on which you type elements
# Absolute are pointing devices such as touchpad : the position of the pointer is absolute regarding the size of the touch pad
# Relative are pointing devices such as mouse : the position of the pointer is a relative displacement regarding previous position
#
# BEWARE that you must have read access to the wanted device

#vrpn_DevInput           Input0          "AT Translated keyboard" keyboard 255
#vrpn_DevInput           Input0          "USB Optical Mouse" relative -1

################################################################################
# MotionNode inertial tracking system.
#
# There are four arguments:
#	char	name_of_this_device[]
#	int	num_sensors
#	char	address
#	int	port

#vrpn_Tracker_MotionNode Tracker0 1 127.0.0.1 32079

################################################################################
# GPS device.
# This driver reads a GPS connected to the serial port at a given baud rate, and looks for
# the NMEA message providing long/lat/alt, which get copied into x/y/z
# respectively (of the position).  Should do a lot more (e.g., get velocity,
# bearing, perhaps convert to UTM).  But, for now, this is all it does.

# Open a GPS on MACOSX at 4800 baud

#vrpn_Tracker_GPS       Tracker0        /dev/tty.KeySerial1     4800
#vrpn_Tracker_GPS       Tracker0        /dev/tty.HOLUXGPSlim236-SPPslave-1      4800

#on windows
#vrpn_Tracker_GPS       Tracker0        COM1    4800

################################################################################
# Nintendo Wii Remote Controller
#	char	name_of_this_device[]
#	int	userIndex (1 for "Player 1", 2 for "Player 2", etc.)
#	int useMotionSensing
#	int useIR
#   int reorderButtons (set to make button ids somewhat more sensible)
#   char    bluetooth_address[] (optional, only supported on Linux - upper case,
#                                include colons)

#vrpn_WiiMote		WiiMote0 1 0 0 1

################################################################################
# Two-LED head tracking using Wii Remote Controller
#	char	name_of_this_device[]
#	char    name_of_vrpn_WiiMote_device[]
#	float   min_update_rate (default=60)
#	float   led_distance (default=0.205)
#
# Note: The WiiMote device must have useMotionSensing = 1 and useIR = 1

#vrpn_WiiMote		WiiMote0 1 1 1 1
#vrpn_Tracker_WiimoteHead  Tracker0 WiiMote0@localhost

################################################################################
# Novint Falcon attached to USB.
# Arguments:
#      char name_of_this_device[]
#      int  device index (starts at 0)
#      char name_of_grip (optional, default and only one supported now = "4-button")
#      char kinematic_model (optional, default and only one supported now ="stamper")
#      float damping_factor (optional, range 1.0-1000.0, default=10.0)
#vrpn_Tracker_NovintFalcon  Tracker0  0  4-button stamper 10.0

################################################################################
# Hillcrest Labs Freespace device
#	char	name_of_this_device[]
#	int	Index (0 for device 1, 1 for device 2, ...)
#	int	Send body frames (0 = no, 1 = yes)
#	int	Send user frames (0 = no, 1 = yes)

#vrpn_Freespace		FreeSpace0 0 1 1

################################################################################
# Dream Cheeky devices, of which only the USB Roll-Up Drum Kit is implemented.
#
# There is one argument:
#	char	name_of_this_device[]

#vrpn_Dream_Cheeky_USB_roll_up_drums drums0

################################################################################
# (OBSOLETE) Trivisio Colibri device.  This is an inertial tracker that gives
# orientation information, no position (the tracker reports (0, 0, 0) for position).
#
# Arguments:
#	char	name_of_this_device[]
#	int     number_of_sensors (Number of connected devices to connect to)
#	int     Hz (Update rate)
#	int	bufLen	(From the reference manual:
#			An short buffer (0) ensures minimal delay until the sensor
#			measurement is available at the risk of lost measurements.
#			A long buffer guarantees that no data is dropped, at
#			the same time if data is not read fast enough there is a
#			potential risk of a bufLen frequency before the measurement
#			becomes available.)

#vrpn_Tracker_TrivisioColibri Colibri 1 60 0

################################################################################
# Trivisio ColibriAPI support.  This is an inertial tracker that gives orientation
# information, no position (the tracker reports (0, 0, 0) for position).
# If wireless Colibri do not answer, dongle scans for them automatically (20 seconds).
# Wireless Colibri must be in scanning mode (button pushed for 2 seconds,
# LED flashing fast).
#
# Arguments:
#	char	name_of_this_device[]
#	char	conf_file_name[] : xml-file with sensor network configuration.
#               Use Colibri GUI to create the file. Settings must be set
#               and saved in sensors' non-volatile memory using Colibri GUI.
#               * - to use all connected devices. Default settings will be
#               applied to sensors.
#	int     Hz : Update rate.
#	int     report_a_w : 0 = orientation only,
#                        1 = orientation + angular velocity + acceleration.

#vrpn_Tracker_Colibri Colibri * 100 0

################################################################################
# LUDL USBMAC6000 device.  This is a vrpn_Analog and a vrpn_Analog_Output device
# that lets you both move the stage by command and get a response when it has
# finished moving.
#
# Arguments:
#	char	name_of_this_device[]
#	int	Perform recentering on device (0 = no, 1 = yes)

#vrpn_LUDL_USBMAC6000 Analog0 1

################################################################################
# GameTrak tracker
# Reports 2 sensors with positions only
# This device uses another joystick device that needs to be configured (PC
# version of GameTrak shows up as a joystick device with 6 axes and a button)
# If the name of the joystick device starts with '*', it will take another
# one on this server, otherwise it will attempt a remote connection
#   char    name_of_this_device[]
#   char    name of the joystick device[]
#vrpn_Joylin  RawGametrak /dev/input/js1
#vrpn_Tracker_GameTrak GameTrak0 *RawGametrak


################################################################################
# PNI SpacePoint Fusion 3DOF rotation tracker
# Reports 1 sensor as quaternion.
# The device index can be specified in order to open multiple identical devices,
# if not specified, 0 is assumed.
#   char    name_of_this_device[]
#   [int    device index]

#vrpn_Tracker_SpacePoint SpacePoint0 0

################################################################################
# 5DT DataGlove "Ultra" USB/USB Wireless support (based on HID)
#
# Reports 5 or 14 sensors' raw values as analogs 0-4 or 0-13, in range 0.0 - 1.0
# Note that your code will probably need to perform some scaling/calibration:
# see vrpn_Analog_5dtUSB.h for more info
#
# Four device types as shown in examples below: the server will connect to the
# first device available of that type.
#
# For serial (non-"Ultra") gloves, see vrpn_5dt and vrpn_5DT16
#
# Arguments:
#   char    name_of_this_device[]

#vrpn_Analog_5dtUSB_Glove5Right Glove5Right
#vrpn_Analog_5dtUSB_Glove5Left Glove5Left
#vrpn_Analog_5dtUSB_Glove14Right Glove14Right
#vrpn_Analog_5dtUSB_Glove14Left Glove14Left

################################################################################
# JsonNet devices
#
# Any device that send updates formatted as JSON messages over UDP, including
# Vrpn Widgets for Android
#
# Messages are:
#   for a tracker:
#     {
#       'type': 1,
#       'id': sensor number,
#       'quat': quaternion,
#       'pos': position
#     }
#
#   for a button:
#     {
#       'type': 2,
#       'button': button number,
#       'state': the boolean state
#     }
#
#   for an analog:
#     {
#       'type': 3,
#       'num': channel number,
#       'data': the analog value
#     }
#   for a text message:
#     {
#       'type': 4,
#       'data': the text value
#     }
#
# Arguments:
#  char  name_of_this_device[]
#  int   udp_port                               (Device send JSON messages to this port)

#vrpn_Tracker_JsonNet Jsonnet  7777

################################################################################
# One-Euro Filter Tracker. This is a tracker that is intended to be used on top of
# another tracker to provide filtered output for it.  This was originally designed
# for the Razer Hydra, but can be used along with any tracker.
#
# Arguments:
#	char  name_of_this_device[]
#	char  name_of_tracker_to_filter[]		(start with * for local)
#	int	  number_of_sensors_to_filter
#	float vecMinCutoff
#	float vecBeta
#	float vecDerivativeCutoff
#	float quatMinCutoff
#	float quatBeta
#	float quatDerivativeCutoff

#vrpn_Tracker_FilterOneEuro Filter0  *Tracker0  2  1.15 1.0 1.2  1.5 5.0 1.2

################################################################################
# Razer Hydra (Sixense TrueMotion) tracker (HID-based driver)
#
# The left wand (the one with LB and LT on its "end" buttons - look from above)
# is sensor 0, and the right wand (with RB and RT on it) is sensor 1.
# The "front" of the base is the side opposite the cables: there's a small
# logo on it. You can have the base in any orientation you want, but the info
# that follows assumes you have the base sitting on a desk, with the front toward you.
# If you have the base in a different coordinate frame in the world, please make
# the appropriate mental transformations yourself. :)
#
# When starting the VRPN server, make sure that the left wand is somewhere to
# the left of the base, and the right wand somewhere right of the base -
# they do not need to be placed on the base or any more complicated homing/calibration
# procedure. This is for the hemisphere tracking: it needs to have an "initial state"
# that is roughly known, so it uses the sign of the X coordinate position.
#
# The base coordinate system is right-handed with the axes:
#  X - out the right of the base
#  Y - out the front of the base
#  Z - down
#
# The wands are also right-handed, with the tracked point somewhere near
# the cable entry to the controller . When held with the joystick vertical,
# the axes are:
#  X - to the right
#  Y - out the front of the controller (trigger buttons)
#  Z - Up, along the joystick
#
#  Buttons are as follows, with the right controller's button channels starting
# at 8 instead of 0:
#  0 - "middle" button below joystick
#  1-4 - numbered buttons
#  5 - "bumper" button (above trigger)
#  6 - joystick button (if you push straight down on the joystick)
#  There is no button 7 on any controller; the offset of 8 per controller
# was done to make similar buttons differ by a power of 2.
#
# Analog channels are as follows, with the right controller starting at 3
# instead of 0:
#  0 - joystick left/right: centered at 0, right is positive, in [-1, 1]
#  1 - joystick up/down: centered at 0, up is positive, in [-1, 1]
#  2 - analog trigger, in range 0 (not pressed) to 1 (fully pressed).
#
# Arguments:
#   char    name_of_this_device[]
#
# NOTE: If using the Hydra on Windows, the server will work with or without the official
# Razer Hydra drivers installed. If you are only using the device with VRPN, don't
# install the official drivers. However, if you do have them installed, make sure that
# the "Hydra Configurator" and the Hydra system tray icon are closed to avoid unexpected
# failure (their software can switch the device out of the mode that VRPN uses). You
# probably want to make sure that the tray icon doesn't auto-run on startup, since it
# can get even messier with Windows 7's "switch users" if you let it auto-run for each
# user.
#
# Works great on Linux (regardless of endianness) - no drivers needed, thanks to USB HID.
#
# NOTE: Because of the jitter in the tracker, you may want to add a
# filter to it and then read the filtered location values; you still read
# the buttons and analogs from the original device.
#

#vrpn_Tracker_RazerHydra Tracker0
#vrpn_Tracker_FilterOneEuro Filter0 *Tracker0  2  1.15 1.0 1.2  1.5 5.0 1.2

################################################################################
# Sensics zSight HMD with built-in tracker.  This is an inertial tracker that 
# gives orientation information, but no position (the tracker reports 
# (0, 0, 0) for position).
#
# Arguments:
#	char	name_of_this_device[]

#vrpn_Tracker_zSight zSight

################################################################################
# Arrington Research ViewPoint EyeTracker.
#
# The VRPN server connects to the eye tracker using the VPX_InterApp DLL.
# Whatever other control software is being used to connect to the eye tracker
# (e.g. the ViewPoint software that comes with the tracker) to perform
# calibration, etc. should link to the same copy of the DLL, so they can share
# information.
#
#-------------------------------------------------------------------------------
#
# Tracker:
#
# The tracker has two sensors, as the ViewPoint can optionally have binocular
# tracking.  In the case of monocular tracking, only sensor 0 (EYE_A) will have
# valid information.  Retrieving smoothed or raw tracking data is controlled by
# the smoothedData parameter.
#
# Position: The (x,y) gaze point in gaze space (smoothed or raw).
#
# Rotation: The (x,y) gaze angle as a quaternion (smoothed or raw).
#
# Velocity: The x- and y- components of the eye movement velocity in gaze space
# (always smoothed).
#
#-------------------------------------------------------------------------------
#
# Analog:
#
# There are a lot of additional data that can be retrieved from the tracker.
# These values are always calculated from the smoothed gaze point.  Currently,
# the following are sent as analog values, but more can be added as needed.
# Please see the ViewPoint documentation regarding what other data are available.
#
# Because each channel needs to be duplicated in the case of a binocular tracker,
# the first n/2 values are for EYE_A, and the second n/2 values are for EYE_B.
#
# EYE_A:
#
# Channel 0: The pupil aspect ratio, from 0.0 to 1.0.  Can be used to detect
#            blinks when it falls below a given threshold.
#
# Channel 1: The total velocity (magnitude of eye movement velocity).  Can be
#            used to detect saccades.
#
# Channel 2: The fixation seconds (length of time below the velocity criterion
#            used to detect saccades).  0 if saccade is occurring.
#
# EYE_B:
#
# Channels 3-5: See EYE_A.
#
#-------------------------------------------------------------------------------
#
# Arguments:
#  char  name_of_this_device[]
#  int   smoothedData

# vrpn_Tracker_ViewPoint ViewPoint 1

################################################################################
# vrpn_inertiamouse
# (Need a description of how to run this and an example commented-out line.)

###############################################################################
# To access Polhemus G4 on Windows using the Polhemus PDI library,
# use vrpn_Tracker_G4.
#
# The vrpn_Tracker_G4 tracker definition requires the tracker name and 
# the vrpn server name for the tracker, followed by an optional Server Poll rate,
# and on the next line, the file path to the .g4c configuration file:
#
# vrpn_Tracker_G4 G4 \
# C:\filepath\source_config_file.g4c
#
# The Server Poll Rate is optional.  
# If it is not specified, the VRPN server will poll for new data at a rate of 120 frames per second.  
# (120 frames per second is the default output rate of G4 hardware.)
#
# If you wish to poll at a slower rate than the tracker, you may specify any number.  For example, if
#   you wish to poll 20 times per second, then specify a poll rate of 20.  
#
# The '\' at the end of the first line, after the server name, is optional and
# will be disregarded.  A '\' on a subsequent line means that further commands
# are to be input. The format is to have one command per line after the file
# path.  Each line that isn't the final line must end in a '\'.
#	The final line should not have a '\' on the end.
#
# Supported G4 Configuration Commands:
#	'B'		Set/Reset Boresight
#	'X'		Set/Reset Position Filter
#	'Y'		Set/Reset Attitude Filter
#	'T'		Set/Reset G4 Translation Frame of Reference
#	'R'		Set/Reset G4 Rotation Frame of Reference
#	'I'		Set/Reset Sensor Increment/Auto-Increment
#	'N'		Set/Reset Sensor Tip Offset
#
# The following commands are not G4 configuration commands but are used to
# create VRPN button server objects for G4 button devices:
#
#   'G4PowerTrak' Creates VRPN button server object with 4 buttons
#   'G4DigIO'   Creates VRPN button server object with a configurable button count
#
# Command Syntax:
#------------------------------------------------------------------------------
# 'B' Boresight Command 'B':
#
#		Syntax:	Baction,hub,sensor,[x,y,z,w]
#
#		Arguments:
#			action:
#					1 = Boresight
#					2 = Unboresight
#
#			hub:		HubID. (0-based.) To apply Boresight/Unboresight to all hubs & sensors, set to * or -1.
#			sensor:		Sensor Num. (0-based.) To apply Boresight/Unboresight to all sensors on a hub, set to *
#								Note: If hub is *, set sensor to * also.
#			[x,y,z,w]:	Optional Quaternion XYZW Boresight Reference Orientation.
#						All 4 values must be set.
#						N/A for action=2
#
#		Examples:
#			B2,-1,-1	Un-Boresights all sensors on all hubs
#			B1,-1,-1	Boresights all sensors on all hubs
#			B1,1,-1,
#------------------------------------------------------------------------------
# 'X' Position Filter Command 'X':
# 'Y' Attitude Filter Command 'Y':
#
#		Syntax:	Xaction,hub,flevel,[F,FLow,FHigh,Factor]
#				Yaction,hub,flevel,[F,FLow,FHigh,Factor]
#
#		Arguments:
#			action:
#					1 = Set
#					2 = Reset
#
#			hub:		HubID. (0-based.) To apply filter to all hubs, set to *
#			flevel:		Filter Level
#						0=None
#						1=Light
#						2=Medium
#						3=Heavy
#						4=Custom
#			[F,FLow,FHigh,Factor]:	Optional Floating-point Parameters used only if flevel=Custom.
#									If custom parameters are used, it is assumed that all four custom parameters are present.
#									See Tracker User manual for meaning of Custom Filter Values.
#		Examples:
#			X*,1					Sets Position Filtering to LIGHT on all hubs
#			Y2,0					Sets Attitude Filtering to NONE on hub 2
#			X1,4,0.2,0.2,0.8,0.95	Sets Custom Filter on hub 1
#------------------------------------------------------------------------------
#	'T'	Translation Frame of Reference Command 'T':
#
#		Syntax:	Taction,x,y,z
#
#		Arguments:
#			action:
#					1 = Set
#					2 = Reset
#
#			x,y,z:	Position Offset, measured in Meters
#					All arguments must be present
#
#		Examples:
#			T1,1.0,1.5,1.0			Sets Translation Frame of Reference to (1.0, 1.5, 1.0) meters
#			Y2						Resets Translation Frame of Reference
#
#		Note: Frame of Reference commands apply to all G4 output.
#------------------------------------------------------------------------------
#	'R'	Rotation Frame of Reference Command 'R':
#
#		Syntax:	Raction,hub,x,y,z,w
#
#		Arguments:
#			action:
#					1 = Set
#					2 = Reset
#
#			x,y,z,w:	Rotation Quaternion XYZW
#						All arguments must be present
#
#		Examples:
#			R1,0,0,0.707107,0.707107 Sets Rotation Frame of Reference
#			R2						 Resets Rotation Frame of Reference
#
#		Note: Frame of Reference commands apply to all G4 output.
#------------------------------------------------------------------------------
#	'I'	Increment/AutoIncrement Command 'I':
#
#		Syntax:	Iaction,hub,sensor,fPosIncr,fOriIncr
#
#		Arguments:
#			action:
#					1 = Set
#					2 = Reset
#
#			hub:		HubID. (0-based.) To apply command to all hubs & sensors, set to * or -1
#			sensor:		Sensor Num. (0-based.) To apply command to all sensors on a hub, set to * or -1
#								Note: If hub is *, set sensor to * also.
#
#			posIncr:	Position Threshold, Meters
#						 0 Disables
#						-1 Enables Auto-Increment
#
#			oriIncr:	Orientation Threshold, DEGREES
#						 0 Disables
#						-1 Enables Auto-Increment
#
#		Examples:
#			I1,*,*,0.01,5.0	 For all hubs/sensors, sets position increment to 10 cm,
#													    rotation increment to 5 degrees
#			I1,*,*,-1,-1	 For all hubs/sensors, enables position and rotation auto-increment
#			I2,0,2			 For hub0, sensor2, resets/disables increment
#
#------------------------------------------------------------------------------
#	'N'	Tip Offset Command 'N':
#
#		Syntax:	Iaction,hub,sensor,x,y,z
#
#		Arguments:
#			action:
#					1 = Set
#					2 = Reset
#
#			hub:		HubID. (0-based.) To apply command to all hubs & sensors, set to * or -1
#			sensor:		Sensor Num. (0-based.) To apply command to all sensors on a hub, set to * or -1
#								Note: If hub is *, set sensor to * also.
#
#			x,y,z:	Position Offset, measured in Meters
#					All arguments must be present
#
#		Examples:
#			N1,0,0,0.005,0.001,0.001	For hub0,sensor0, sets tip offset to (5,1,1)cm
#			N2,*,*						For all hubs/sensors, resets tip offset
#
#
#------------------------------------------------------------------------------
#	'G4PowerTrak' Command	:
#    If one or more hubs in the polhemus g4 system supports a Polhemus PowerTrak360, use this
#    command to create a vrpn button object with 4 buttons.
#
#		Syntax:	G4PowerTrak name hub
#
#       Arguments:
#           name:	Button Server Name
#           hub:	HubID. (0-based) Identifier of the hub to which the PowerTrak360 is connected.
#
#		Examples:
#			G4PowerTrak  ptrak0	0	For 4-button server named ptrak0 plugged into Hub 0.
#
#       Remember that the "remote" button object is not the same as the the tracking device, so be sure
#       to use a remote button object that connects to the button rather than the tracker.
#       In this example configuration, if the name of the machine running the server is "mytrackerserver"
#       you would connect to the tracker as "myg4@mytrackerserver" and to the powertrak configured
#       here as "ptrak0@mytrackerserver"
#
#		Note:  It is possible to have >1 G4PowerTrak configured on a vrpn_Tracker_G4, but they must be
#				on different hubs.
#			   It is also possible to have a combination of G4PowerTrak and G4DigIO commands, but they
#				must be on different hubs.
#
#------------------------------------------------------------------------------
#	'G4DigIO' Command:
#    If one or more hubs in the polhemus g4 system supports a custom digital IO accessory, use this
#	 command to create a vrpn button object with a configurable number of buttons
#
#		Syntax:	G4DigIO name hub inputs
#
#       Arguments:
#           name:	Button Server Name
#           hub:	HubID. (0-based) Identifier of the hub to which the digital IO device is connected.
#           inputs:	Number of digital inputs (buttons) to capture.
#						The G4 Digital I/O interface supports up to 8 digital inputs. The 'inputs'
#						argument must be between 1 and 8, inclusive.
#
#		Examples:
#			G4DigIO 2btn0	0	For 2-button server named 2btnio0 plugged into Hub 0.
#			G4DigIO 8sig4	8	For an 8-button server named 8sig4 plugged into Hub 4.
#
#       Remember that the "remote" button object is not the same as the the tracking device, so be sure
#       to use a remote button object that connects to the button rather than the tracker.
#       In this example configuration, if the name of the machine running the server is "mytrackerserver"
#       you would connect to the tracker as "myg4@mytrackerserver" and to the G4DigIO configured
#       here as "2btn0@mytrackerserver" or "8btn4@mytrackerserver".
#
#		Note:  It is possible to have >1 G4DigIO configured on a vrpn_Tracker_G4, but they must be
#				on different hubs.
#			   It is also possible to have a combination of G4PowerTrak and G4DigIO commands, but they
#				must be on different hubs.
#
#------------------------------------------------------------------------------
# Example command for setup of a G4
#
# vrpn_Tracker_G4	G4\
# C:\Program Files (x86)\Polhemus\G4\G4 Files\mysourceconfig.g4c \
# G4PowerTrak myptraka 1
# G4PowerTrak myptrakb 2
# B1,-1,-1\
# X1,*,1\
# Y1,*,4,0.2,0.2,0.8,0.95\
# T1, 10.0, 10.0, 10.0, 10.0\
# R1,0,0,0,1\
# I1,*,*,0.01,5.0\
# N1,0,*,0.005,0.002,0.001\
# N2,*,*

###############################################################################
# To access Polhemus FasTrak on Windows using the Polhemus PDI library,
# use vrpn_Tracker_FastrakPDI.
#
# The vrpn_Tracker_FastrakPDI tracker definition requires the tracker name and 
# the vrpn server name for the tracker, followed by an optional Server Poll rate:
#
# vrpn_Tracker_FastrakPDI myFastrak4   30\       <-valid
# vrpn_Tracker_FastrakPDI myFastrak2   60\       <-valid
# vrpn_Tracker_FastrakPDI myFastrak1     \       <-valid
#
# The Server Poll Rate is optional.  
# If it is not specified, the VRPN server will poll for new data at a rate of 120 frames per second.  
# (120 frames per second is the default output rate of FasTrak hardware with ONE sensor connected.)
# 
# For FasTrak trackers the update rate depends on the number of sensors connected to the device:
#   Number of Sensors         Update Rate
#   -----------------         -----------
#         1                       120 frames/sec
#         2                        60 frames/sec  
#         3                        40 frames/sec
#         4                        30 frames/sec
#
# If you wish to poll at the same rate as the tracker output, then you must specify the poll rate 
#   to match the update rate in the table above.
#
# If you wish to poll at a slower rate than the tracker, you may specify any number.  For example, if
#   you wish to poll 20 times per second, then specify and update rate of 20.  
#
# The '\' at the end of the first line, after the server name, is optional and will be disregarded.
#   a '\' on a subsequent line means that further commands are to be input. The format is to have
#   one command per line.  Each line that isn't the final line must end in a '\'.  The final line should not
#   have a '\' on the end.
#
# Supported Fastrak Configuration Commands:
#   All commands are exposed, except C and c for continuous pno which would conflict with VRPN directly.
#   Take note that O<> should be avoided, though it will be sent to the tracker.  VRPN clients expect position
#   x,y,z and quaternion q,r,s,t by default, so changing the frame structure could result in an overflow.
#   The format commands ('F' for ASCII, f for binary) are especially useful since the tracker can mark
#   syntax errors in ASCII mode.  The tracker must be in binary mode for VRPN to gather data, so if you issue
#   an F command at some point in this file (to troubleshoot syntax errors), be sure to issue an f<>
#   command later.  Not all fastrak commands have a response: boresight, for example.  You can confirm
#   such settings by requesting a single frame in ASCII mode with the command P (note, P requires no <>).
#   Read the fastrak manual for a full list of commands.
#
# Command Syntax:
#   Many commands, much like P (gather single pno frame), require no carriage return on the end.  Carriage
#   returns are represented by '<>'.  Control commands, noted as ^$ (where $ is any capitol letter) in the
#   manual require a '^' followed by the capital letter for the command.  Syntax is precisely as given in
#   examples in the fastrak manual.  Note that all commands are case sensitive.
#    Examples:
#     F              <-Sets the response frame format to ASCII
#     f              <-Sets the response frame format to binary
#     b*<>           <-Removes the boresight setting for all sensors
#     B1<>           <-Sets the boresight to 0,0,0 as a default or whatever G<> was set to
#     G1,0,0,0<>     <-Sets the boresight reference angles of station 1 to 0,0,0
#     ^Y             <-Sends a reset command to the tracker, note that VRPN defaults for pno will be loaded on
#                       reconnect
#
# If a sensor on the FasTrak device is a Polhemus FasTrak Stylus, use the "PDIStylus"
#   command.  This command takes one argument: the station number of the stylus device.  Remember that
#   the station number is a 1-based index of sensors/'stations' on the Polhemus equipment.
#   PDIStylus command syntax:
#
#   PDIStylus [station-num]
#
#   Use of the PDIStylus command will
#   - Cause the Stylus Button Flag to be configured into the output of all stations.
#   - Cause the creation of vrpn button device.  The name of this device will be a concatenation of
#		the server name for the tracker + "Stylus" + the specified station number.
#       E.g:
#			vrpn_Tracker_FasTrakPDI   myFT \
#           PDIStylus 1
#
#           Will produce a button device named "myFTStylus1"
#
#       Remember that the "remote" button object is not the same as the the tracking device, so be sure
#       to use a remote button object that connects to the button rather than the tracker.
#       In this example configuration, if the name of the machine running the server is "mytrackerserver"
#       you would connect to the tracker as "myFT@mytrackerserver" and to the button on the stylus as
#       "myFTStylus1@mytrackerserver"
#
#   NOTE:  The FasTrak tracker will only detect stylus input if the stylus is plugged into Station 1!
#          However, the stylus flag can be output onto any station on the device.  Therefore, it is
#          possible to specify station 2 as your PDIStylus button, and the stylus output will be collected
#          from the Station 2 output.  BUT the actual Stylus device must be plugged into Station 1.
#          This means that only one Stylus can be plugged into a FasTrak at any time, but up to 4 vrpn
#          button objects can be created/accessed from that Stylus.
#
#------------------------------------------------------------------------------
# The following example config:
# -specifies that station 1 is a FasTrak Stylus Device
# -sets the tracker to ASCII responses (F),
# -sets the boresight reference on sensor one to 0,0,0, (G1,0,0,0<>)
# -writes this reference to the system with B1<>,
# -confirms the change by collecting a single pno with P,
# -removes the boresight setting (^b1<>),
# -collects a second single pno to confirm this removal (P) and
# -finally returns to binary mode before passing control to VRPN (F1<>).
# The trackers name is TrackerJoe.
# The server poll rate is 120 Hz.   

# vrpn_Tracker_FastrakPDI	TrackerJoe    120\
# PDIStylus 1\
# F\
# G1,0,0,0<>\
# B1<>\
# P\
# b1<>\
# P\
# f

#------------------------------------------------------------------------------
# The default config is below.
# -Assumes that one sensor is connected to FasTrak, and polls at 120 Hz

# vrpn_Tracker_FastrakPDI myFasTrak

###############################################################################
# To access Polhemus Liberty or Patriot on Windows using the Polhemus PDI library,
# use vrpn_Tracker_LibertyPDI.
#
# The vrpn_Tracker_LibertyPDI tracker definition requires the tracker name and 
# the vrpn server name for the tracker, followed by an optional Server Poll rate:
#
# vrpn_Tracker_LibertyPDI MyLiberty        240\       <-valid
# vrpn_Tracker_LibertyPDI MyPatriot           \       <-valid
# vrpn_Tracker_LibertyPDI MyPolhemus       120\         <-valid
#
# Note that "Tracker_LibertyPDI" is used for both Polhemus Patriot and Liberty tracker hardware!
#
# The Server Poll Rate is optional.  
# If it is not specified, the VRPN server will poll for new data at a rate of 60 frames per second.  
# (60 frames per second is the default output rate of Patriot tracker hardware.)
# 
# For Liberty trackers, the default rate is 240 frames per second.  If you wish for the server to poll
#   at this rate, then you must specify 240!
#
# If you wish to poll at a slower rate than the tracker, you may specify any number.  For example, if
#   you wish to poll 20 times per second, then specify and update rate of 20.  
# 
# The '\' at the end of the first line, after the server name, is optional and will be disregarded.
#   a '\' on a subsequent line means that further commands are to be input. The format is to have
#   one command per line.  Each line that isn't the final line must end in a '\'.  The final line should not
#   have a '\' on the end.
#
# Supported Liberty/Patriot Configuration Commands:
#   All commands are accepted, except C<> for continuous pno output which would conflict with VRPN directly.
#   Take note that O<> should be avoided, though it will be sent to the tracker.  VRPN clients expect position
#   x,y,z and quaternion q,r,s,t by default, so changing the frame structure could result in an overflow.
#   The format command (F0<> for ASCII, F1<> for binary) is especially useful since the tracker can mark
#   syntax errors in ASCII mode.  The tracker must be in binary mode for VRPN to gather data, so if you issue
#   an F0<> command at the beginning of this file (to troubleshoot syntax errors), be sure to issue an F1<>
#   command later.  Not all liberty/patriot commands have a response: boresight, for example.  You can confirm
#   these settings by requesting a single frame in ASCII mode with the command P (note, P requires no <>).
#   Read the patriot or liberty manual for a full list of commands.
#
#   Note: The R command is used to set the Liberty tracker update rate.  This command has no effect on Patriot.
#     For Liberty, if you use the R command to change the update rate, remember to change the Server Poll Rate
#     specification in the tracker definition (like "MyPolhemus" example above).  

# Command Syntax:
#   Every command, except P (gather single pno frame), requires a carriage return on the end.  Carriage
#   returns are represented by '<>'.  Control commands, noted as ^X (where X is any capitol letter) in the
#   manual require a '^' followed by the capital letter for the command.  Syntax is precisely as given in
#   examples in the patriot/liberty manuals.
#    Examples:
#     ^V<>            <-This command sends a 'whoami' request to the tracker.  Requires ascii mode for response
#     F<>             <-Queries format mode of tracker (binary or ascii)
#     F0<>            <-Sets the response frame format to ASCII
#     F1<>            <-Sets the response frame format to binary
#     ^B*<>           <-Removes the boresight setting for all sensors
#     B1<>            <-Queries the boresight setting for sensor one
#     B1,0,0,0,0      <-Sets the boresight to 0,0,0 without a reset for sensor one
#     ^Y<>            <-Sends a reset command to the tracker, note that VRPN defaults for pno will be loaded on
#                       reconnect
#
# If one or more sensors on the polhemus device is a Polhemus Stylus, use the "PDIStylus"
#   command.  This command takes one argument: the station number of the stylus device.  Remember that
#   the station number is a 1-based index of sensors/'stations' on the Polhemus equipment.
#   PDIStylus command syntax:
#
#   PDIStylus [station-num]
#
#   Use of the PDIStylus command will
#   - Cause the Stylus Button Flag to be configured into the output of all stations.
#   - Cause the creation of vrpn button device.  The name of this device will be a concatenation of
#		the server name for the tracker + "Stylus" + the specified station number.
#       E.g:
#			vrpn_Tracker_LibertyPDI   myliberty \
#           PDIStylus 2
#
#           Will produce a button device named "mylibertyStylus2"
#
#       Remember that the "remote" button object is not the same as the the tracking device, so be sure
#       to use a remote button object that connects to the button rather than the tracker.
#       In this example configuration, if the name of the machine running the server is "mytrackerserver"
#       you would connect to the tracker as "myliberty@mytrackerserver" and to the button on this stylus as
#       "mylibertyStylus2@mytrackerserver"
#
#   NOTE:  The Liberty and Patriots tracker will detect stylus button input on any station, and there is
#          no limit on the number of Stylus devices that can be connected to the tracker.  Only one vrpn
#          button object can be created per stylus.
#
#------------------------------------------------------------------------------
# The following example config for a Liberty tracker:
# -specifies that stations 1 and 2 are Polhemus Stylus Devices
# -sets the tracker to ASCII responses (F0<>),
# -sends the tracker a whoami (^V<>),
# -sets the boresight on sensor one (B1,0,0,0,0<>) to an arbitrary value,
# -confirms the boresight setting with P to collect a single pno,
# -removes the boresight setting (^B1<>),
# -collects a second single pno to confirm (P),
# -enters an invalid command to demonstrate the advantage of ASCII mode (^ZX<>) and finally,
# -most importantly, returns to binary mode before passing control to VRPN (F1<>).
# The tracker server name is myLiberty.
# The server poll rate is 240 Hz
#
# vrpn_Tracker_LibertyPDI	myLiberty  240\
# PDIStylus 1\
# PDIStylus 2\
# F0<>\
# ^V<>\
# B1,0,0,0,0<>\
# P\
# ^B1<>\
# P\
# ^ZX<>\
# F1<>
#
#-----------------------------------------------------------------------------
# Finally the default config below:
# -May be used for a Liberty or a Patriot tracker
# -Polls the tracker 60 times per second 
# -Sets tracker output to ASCII
# -Queries the tracker for WhoAmI information
# -Sets the output back to Binary
##############################################################################

# vrpn_Tracker_LibertyPDI defaultPolhemus\
# F0<>\
# ^V<>\
# F1<>

###############################################################################
# This YEI 3Space_Sensor driver is used even for a wireless-capable sensor
# when it is plugged directly into the computer via USB.  The Wireless
# driver (see next driver description) is used when the wireless unit is
# plugged into the computer.
#
# On Windows, the driver for the YEI 3-Space Sensor Suite requires installation
# of the device driver that comes with the system, which presents a serial-port
# interface to the device (as a COM port on Windows).  On Mac and Linux, you
# can just plug in the device and it will show up as a new port.  On Linux, the
# default permissions for the port only allow read access, so you'll need to
# either change the permissions or run vrpn_server as root.
#   If the gyroscopes are calibrated at startup, the device should remain still
# while the server is started.
#   If the device is set to tare at startup, it should be facing in the correct
# direction when the server is started. This is usually a manufacturing-time
# operation if the tracker is integrated into a larger device.
#
# This device exposes a Tracker interface, with the following inputs.  Only the
# orientation portion of the pose is valid; the position is always reported as
# (0,0,0).  Sensor 1 also reports linear acceleration.
#  0: Untared orientation
#  1: Tared orientation
#
# This device exports an Analog interface, with the following channels:
#  0: Corrected Gyro rate vector X component (radians/second)
#  1: Corrected Gyro rate vector Y component (radians/second)
#  2: Corrected Gyro rate vector Z component (radians/second)
#  3: Corrected Gravity vector X component (in fraction of g)
#  4: Corrected Gravity vector Y component (in fraction of g)
#  5: Corrected Gravity vector Z component (in fraction of g)
#  6: Corrected Compass vector X component (in Gauss)
#  7: Corrected Compass vector Y component (in Gauss)
#  8: Corrected Compass vector Z component (in Gauss)
#  9: Temperature Celsius
#  10: Confidence factor (1 if completely stationary down to 0 with motion)
#
# This device exports a Button_Filter interface, with the following channels:
#  0: First button (external button on the units in cases)
#  1: Second button (external button on the units in cases)
#  2-7: Other buttons (not installed at the factory)
#
# The device description for a wired device:
#  vrpn_YEI_3Space_Sensor
#   char	name_of_this_device[]
#   char	port_name
#   int		baud_rate_of_serial_device
#   int		calibrate_gyros_on_startup (0 = no, 1 = yes)
#   int		tare_on_startup (0 = no, 1 = yes)
#   double	frames_per_second
#   float	red_LED_color to set (0-1)
#   float	green_LED_color to set (0-1)
#   float	blue_LED_color to set (0-1)
#   int		LED_mode (0 = standard, 1 = static)
#
# If the line ends with a backslash character '\', then the following
# line is an additional ASCII command to send to the tracker every
# time it is reset.  There can be more than one such line, so long as
# each previous line ends with backslash.  The commands should not include
# the beginning colon ':' character; it will be prepended automatically.
# Note that the decimal command number is used, with commas and then
# additional commands following.  Also note that there must not be any
# spaces in the commands, and that there must be a space between the
# command and any trailing backslash.
#
# Note that this slash and backslash notation can only be used for the
# YEI tracker, not to extend the line for all other type of device
# listed in this configuration file.
#
# The device description for the first wireless device using a
# dongle includes the following arguments:
#  vrpn_YEI_3Space_Sensor_Wireless
#   char	name_of_this_device[]
#   int     logical_id_on_wireless (0-14)
#   char	port_name
#   int		baud_rate_of_serial_device
#   int		calibrate_gyros_on_startup (0 = no, 1 = yes)
#   int		tare_on_startup (0 = no, 1 = yes)
#   double	frames_per_second
#   float	red_LED_color to set (0-1)
#   float	green_LED_color to set (0-1)
#   float	blue_LED_color to set (0-1)
#   int		LED_mode (0 = standard, 1 = static)
#
# If the line ends with a slash character '/', then the following line
# starts a description of an additional wireless device sharing the
# same dongle.
# The device description for an additional wireless device using the
# same dongle includes the following arguments:
#  vrpn_YEI_3Space_Sensor_Wireless
#   char	name_of_this_device[]
#   int     logical_id_on_wireless (0-14)
#   int		calibrate_gyros_on_startup (0 = no, 1 = yes)
#   int		tare_on_startup (0 = no, 1 = yes)
#   double	frames_per_second
#   float	red_LED_color to set (0-1)
#   float	green_LED_color to set (0-1)
#   float	blue_LED_color to set (0-1)
#   int		LED_mode (0 = standard, 1 = static)
#
# Windows example, then mac example, then Linux example.  Note: Ports may vary
# Note: The parser handles converting Windows ports greater than 9 into
# the correct format, so you can just put the name as COM14 without adding the
# backslashes.
# Final example shows how to use an ASCII reset command to set the
# LED color (it actually just sets it to three different colors,
# the last being yellow).
###############################################################################

#vrpn_YEI_3Space_Sensor	YEI0	COM7	115200	0	0	200.0 0 0 1 0
#vrpn_YEI_3Space_Sensor	YEI0	/dev/cu.usbmodemfa131	115200	0	0	200.0 0 0 1 0
#vrpn_YEI_3Space_Sensor	YEI0	/dev/ttyACM0	115200	0	0	200.0 0 0 1 0

# Example with extra commands sent.  These examples change the LED color
# to multiple differene ones, ending with yellow.
#vrpn_YEI_3Space_Sensor	YEI0	COM7	115200	0	0	200.0 0 0 1 0 \
#238,1,1,1 \
#238,1,0,1 \
#238,1,1,0

# One sensor on a wireless connection.
#vrpn_YEI_3Space_Sensor_Wireless	YEI0	0	COM5	115200	0	0	200.0 0 0 1 1

# Two sensors on the same wireless transmitter.  Note the slash at the end of the
# final line for the first unit, which indicates that we're talking with the
# same base unit for a second wireless tracker (which we then don't specify the
# serial-port name for).
#vrpn_YEI_3Space_Sensor_Wireless	YEI0	0	COM5	115200	0	0	200.0 0 0 1 1 \
#238,1,1,0 /
#vrpn_YEI_3Space_Sensor_Wireless	YEI1	1	0	0	200.0 0 1 0 1 \
#238,0,1,1

################################################################################
# Tracker that does dead-reckoning on orientation based on either reports of
# angular velocity (if received) or on successive orientation reports.
# It sends a new prediction report whenever it receives either a tracker pose
# update or a tracker velocity update.
#	char	name_of_this_device[]
#	char	name_of_device_to_predict_for[]  (start with * for local)
#	int		number_of_sensors
#	float	how_far_to_predict_in_seconds

#vrpn_Tracker_DeadReckoning_Rotation	Tracker1	*Tracker0 2 0.0333

################################################################################
# OSVR Hacker Dev Kit inertial measurement unit.  This is an inertial tracker that 
# gives orientation information, but no position.  Position values are always
# 0.  Version 1 of this device sends only poses.  Version 2 also sends velocity
# reports.
#
# Arguments:
#	char	name_of_this_device[]

#vrpn_Tracker_OSVRHackerDevKit Tracker0

################################################################################
# Oculus Rift DK1 and DK2. There are two versions of the DK2  driver, which use the 
# same hardware but in two different modes.
#
# vrpn_Oculus_DK2_inertial: Oculus DK2 inertial measurement unit only.  This
#  provides access to the magnetometer readings on the unit and has a different
#  set of exported values.
#
# The LEDs device exports an Analog interface, with the following channels:
#  0: Uncalibrated temperature (degrees Celsius?)
#  1: Report ID counter that goes up to 65535 and then cycles back to 0
#  2: Uncalibrated accelerometer X component (positive to left ear) (m/s/s)
#  3: Uncalibrated accelerometer Y component (positive down to feet) (m/s/s)
#  4: Uncalibrated accelerometer Z component (positive forward) (m/s/s)
#  5: Uncalibrated gyro X component (positive rotating head up) (radians/sec?)
#  6: Uncalibrated gyro Y component (positive rotating head left) (radians/sec?)
#  7: Uncalibrated gyro Z component (positive tilting head left) (radians/sec?)
#  8: Uncalibrated Magnetometer X component (positive to left ear) (varied, asymmetric range)
#  9: Uncalibrated Magnetometer Y component (positive down to feet) (varied, asymmetric range)
#  10: Uncalibrated Magnetometer Z component (positive forward) (varied, asymmetric range)
#
# vrpn_Oculus_DK2_LEDs: Oculus with LEDs enabled, which would enable reading
#  from its camera to determine position.  Note that the program reading from
#  the camera will have to put the camera into synchronous mode using a
#  special command before its results will line up with the LED flashing.
#  NOTE: The VRPN driver does not yet read from the camera, so will not produce
#  position reports with the DK2 in this mode, but an external program could
#  read from the camera to do this (after putting it into synchronous mode).
#
# The LEDs device exports an Analog interface, with the following channels:
#  0: Uncalibrated temperature (degrees Celsius?)
#  1: Report ID counter that goes up to 65535 and then cycles back to 0
#  2: Uncalibrated accelerometer X component (positive to left ear) (m/s/s)
#  3: Uncalibrated accelerometer Y component (positive down to feet) (m/s/s)
#  4: Uncalibrated accelerometer Z component (positive forward) (m/s/s)
#  5: Uncalibrated gyro X component (positive rotating head up) (radians/sec?)
#  6: Uncalibrated gyro Y component (positive rotating head left) (radians/sec?)
#  7: Uncalibrated gyro Z component (positive tilting head left) (radians/sec?)
#  8: Uncalibrated Magnetometer X component (positive to left ear) (varied, asymmetric range)
#  9: Uncalibrated Magnetometer Y component (positive down to feet) (varied, asymmetric range)
#  10: Uncalibrated Magnetometer Z component (positive forward) (varied, asymmetric range)
#  11: Time since device power-on (seconds)
#
# NOTE: The Oculus drivers may interfere with this raw driver if they are
#       installed on the system.
#
# NOTE: A side effect of running this driver is that the HMDI output for the
#       DK2 will become visible to the system if it is plugged in.  If it is
#       in DirectMode, it will not appear as a system display.  If it is not,
#       it will show up as another display.
#
# NOTE: The magnetometer ranges on each axis are different, and they are not
#       symmetric around 0 for any of the axes, so the device needs to have been
#       rotated around a lot to really have an idea of which way is North.  A
#       tracker based on this value needs to keep track of the extrema.
#       Also, the magnetic North vector does not point straight along the
#       plane of the ground, but rather into the Earth.  Finally, even with a
#	careful calibration there can still be drift/wobble caused by using
#	the magnetometer, so it is recommended to not use it unless true north
#	is needed.  The system seems stable in rotation without it.
#
# Arguments:
#	char	name_of_this_device[]

#vrpn_Oculus_DK1 Oculus0
#vrpn_Oculus_DK2_inertial Oculus0
#vrpn_Oculus_DK2_LEDs Oculus0

################################################################################
# Magnetometer.  This is an analog that is intended to be used on top of
# an analog that reads values from a 3-axis magnetometer.
#   It could be used on top of any analog device, in fact.
#   This device basically takes in analog signals and puts out analog
# values that are a unit vector.
#   One analog channel is associated with each axis (X, Y, Z)
# For each axis, the value is scaled to a the correct orientation but the
# magnitude will be normalized and offset to fit the largest range of values
# ever received for that axis (self-calibrated).
#   NOTE: The vector will not point perpendicular to gravity.
#   NOTE: The examples below map the axes to the OSVR coordinate system,
# which has +X pointing from the center of the eyes through the right eye,
# the +Y axis pointing straight up, and the +Z axis pointing out the back of
# the user's head.
#
# The device exports an Analog interface, with the following channels:
#  0: X component of normalized, autocalibrated vector
#  1: Y component of normalized, autocalibrated vector
#  2: Z component of normalized, autocalibrated vector
#
#   Arguments:
#	char  name_of_this_device[]
#	float update_rate_to_send_analog_reports
#	[one lines follows, describing the X Y Z, with:
#		char	name_of_analog_device[]		(start with * for local)
#		int	x_channel_of_analog_device
#		float	x_offset					(value ignored)
#		float	x_scale
#		int	y_channel_of_analog_device
#		float	y_offset					(value ignored)
#		float	y_scale
#		int	z_channel_of_analog_device
#		float	z_offset					(value ignored)
#		float	z_scale
#	]

#vrpn_IMU_Magnetometer Magnetometer0 100.0
#*Oculus0 8 0 -1.0 9 0 -1.0 10 0 -1.0

#vrpn_IMU_Magnetometer Magnetometer0 100.0
#*Vality0 6 0 1.0 7 0 1.0 8 0 1.0

################################################################################
# Inertial-measurement combiner.  This is a tracker that combines
# analog values from inertial measurement units and reports orientation
# and orientation velocity.
#   The accelerometer scale parameter should be set to produce values that
# are in meters/second/second.  The rotational input scale parameters should
# be set to produce values that are in radians/second.  The magnetometer
# scale should be set to produce a unit normal vector.
#   One analog device is associated with an accelerometer, one with
# a rotational linear measurement device, and (optionally) one with
# a magnetometer.
#   NOTE: The examples below map the axes to the OSVR coordinate system,
# which has +X pointing from the center of the eyes through the right eye,
# the +Y axis pointing straight up, and the +Z axis pointing out the back of
# the user's head.
#
# The device exports a Tracker interface with one sensor.
#
#   Arguments:
#	char  name_of_this_device[]
#	float update_rate_to_send_reports
#	[two lines follow, describing the accelerometer and rotational inputs:
#		char	name_of_analog_device[]		(start with * for local)
#		int	x_channel_of_analog_device
#		float	x_offset
#		float	x_scale
#		int	y_channel_of_analog_device
#		float	y_offset
#		float	y_scale
#		int	z_channel_of_analog_device
#		float	z_offset
#		float	z_scale
#	]
#	A third following line gives the name of the magnetometer, or the
#	 name NULL if one is not used.  The name starts with * for a device
#	 that should be connected to on the same VRPN connection object
#	 being used for the output.  For some systems, the magnetometer
#	 adds drift/wobble to the orientation estimates, so should not be
#	 used unless true north is required.

#vrpn_IMU_SimpleCombiner Tracker0 400.0
#*Oculus0 2 0 -1.0 3 0 -1.0 4 0 -1.0
#*Oculus0 5 0 1.0 6 0 1.0 7 0 1.0
#NULL

#vrpn_IMU_SimpleCombiner Tracker0 400.0
#*Oculus0 2 0 -1.0 3 0 -1.0 4 0 -1.0
#*Oculus0 5 0 1.0 6 0 1.0 7 0 1.0
#*Magnetometer0

#vrpn_IMU_SimpleCombiner Tracker0 400.0
#*Vality0 1 0 -1.0 0 0 1.0 2 0 1.0
#*Vality0 4 0 -1.0 3 0 1.0 5 0 1.0
#NULL

#vrpn_IMU_SimpleCombiner Tracker0 400.0
#*Vality0 1 0 -1.0 0 0 1.0 2 0 1.0
#*Vality0 4 0 -1.0 3 0 1.0 5 0 1.0
#*Magnetometer0

################################################################################
# nVidia Shield controllers.  The only argument is the name of the device to open.
#
# The vrpn_nVidia_shield_USB is the original Shield controller, which has a
#   touch-pad mouse, plugged into a USB port.
# The vrpn_nVidia_shield_stealth_USB is the newer model, which has a tesselated
#   exterior and no touch pad.
#
# Note: On a mac, the shield controller sometimes requests shutdown on the machine
#       when it is plugged in, and the volume controls control the volume,
#       and the shield emblem causes it to sleep.  The events are still
#       passed through to VRPN.  Also on a Mac, the Stealth controller does
#       not present reports to VPRN, so is not useful.
# Note: On Windows 8.1, this controller's touch pad controls the mouse and
#       its analog events are not passed on to VRPN.
# On Linux, there are no system controls and all of the events are passed through
#   to VRPN.
# Note: The rumble outputs are not yet implemented on the Stealth.
# Note: The mappings are the same for both devices, but the Stealth does
#       not report some (which remain 0/off).
#
# Analogs:
#  analog[0] is the left joystick X, -1 to left and 1 to right.
#  analog[1] is the left joystick Y, -1 up and 1 down.
#  analog[2] is the right joystick X, -1 to left and 1 to right.
#  analog[3] is the right joystick Y, -1 up and 1 down.
#  analog[4] is the left finger bumper, 0 unpressed and 1 pressed fully.
#  analog[5] is the right finger bumper, 0 unpressed and 1 pressed fully.
#  analog[6] is the touch pad X axis, lower to left and higher to right
#            (Missing on the stealth)
#  analog[7] is the touch pad Y axis, lower to top and higher to bottom
#            (Missing on the stealth)
#  analog[8] is the hi-hat X position (-1 left, 0 center, 1 right)
#  analog[9] is the hi-hat Y position (-1 up, 0 center, 1 down)
#
# Buttons:
#  button[0] A
#  button[1] B
#  button[2] X
#  button[3] Y
#  button[4] Left finger trigger
#  button[5] Right finger trigger
#  button[6] Left joystick pushed down
#  button[7] Right joystick pushed down
#  button[8] Touch pad assembly (including volume control) pressed down
#            (Missing on the stealth)
#  button[9] Play/pause icon touched
#  button[10] Unknown
#  button[11] Right volume control (+) pressed
#            (Left arrow on the stealth)
#  button[12] Left volume control (-) pressed
#            (Circle on the stealth)
#  button[13] Shield emblem touched
#  button[14] Back icon touched
#  button[15] Home icon touched
#  button[16] Hi-hat up pressed (may chord with left/right)
#  button[17] Hi-hat right pressed (may chord with up/down)
#  button[18] Hi-hat down pressed (may chord with left/right)
#  button[19] Hi-hat left pressed (may chord with up/down)
#  button[20] Touch pad touched
#

#vrpn_nVidia_shield_USB shield0
#vrpn_nVidia_shield_stealth_USB shield0

################################################################################
# Adafruit 10DOF IMU I2C controller driver for Raspberry Pi.
#	char	name_of_this_device[]
#	char	name_of_system_device_to_open[]
#	float	update_interval_in_seconds
#
# Analogs:
#  analog[0] is the X axis for the accelerometer, in meters/second/second
#  analog[1] is the Y axis for the accelerometer, in meters/second/second
#  analog[2] is the Z axis for the accelerometer, in meters/second/second
#  analog[3] is the X axis for the rate gyro, in radians/second
#  analog[4] is the Y axis for the rate gyro, in radians/second
#  analog[5] is the Z axis for the rate gyro, in radians/second
#  analog[6] is the X axis for the magnetometer, in XXX
#  analog[7] is the Y axis for the magnetometer, in XXX
#  analog[8] is the Z axis for the magnetometer, in XXX
#  analog[9] will be the temperature in Celcius (not impl. as of 7/2016)
#  analog[10] will be the pressure in Pascal (not impl. as of 7/2016)
# NOTE: This class is not completely implemented as of 7/2016.
#  The accelerometer and gyro may be reading, but they are raw readings.

#vrpn_Adafruit_10DOF Analog0 /dev/i2c-1 10e-3

################################################################################
# OzzMaker BerryIMUIMU I2C controller driver for Raspberry Pi.
#	char	name_of_this_device[]
#	char	name_of_system_device_to_open[]
#	float	update_interval_in_seconds
#
# Analogs:
#  analog[0] is the X axis for the accelerometer, in meters/second/second
#  analog[1] is the Y axis for the accelerometer, in meters/second/second
#  analog[2] is the Z axis for the accelerometer, in meters/second/second
#  analog[3] is the X axis for the rate gyro, in radians/second
#  analog[4] is the Y axis for the rate gyro, in radians/second
#  analog[5] is the Z axis for the rate gyro, in radians/second
#  analog[6] is the X axis for the magnetometer, in Gauss
#  analog[7] is the Y axis for the magnetometer, in Gauss
#  analog[8] is the Z axis for the magnetometer, in Gauss
#  analog[9] will be the temperature in Celcius (not impl. as of 7/2016)
#  analog[10] will be the pressure in Pascal (not impl. as of 7/2016)

#vrpn_OzzMaker_BerryIMU Analog0 /dev/i2c-1 10e-3

# Laputa VR HMD inertial measurement unit.  This driver only provides IMU reports
# via analog and will need to use IMU combiner to get an orientation out of it.
#
# Arguments:
#	char	name_of_this_device[]

#vrpn_Laputa Laputa0

################################################################################
# vGlass Vality vGlass head-mounted display.
#	char	name_of_this_device[]
#
# Analogs:
#  analog[0] is the X axis for the accelerometer, in meters/second/second
#  analog[1] is the Y axis for the accelerometer, in meters/second/second
#  analog[2] is the Z axis for the accelerometer, in meters/second/second
#  analog[3] is the X axis for the rate gyro, in radians/second
#  analog[4] is the Y axis for the rate gyro, in radians/second
#  analog[5] is the Z axis for the rate gyro, in radians/second
#  (As of 7/11/2019, the magnetometer readings are not parsed.)
#  analog[6] is the X axis for the magnetometer, in microTesla
#  analog[7] is the Y axis for the magnetometer, in microTesla
#  analog[8] is the Z axis for the magnetometer, in microTesla

#vrpn_Vality_vGlass Vality0
