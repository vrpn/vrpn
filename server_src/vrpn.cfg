# vrpn.cfg SAMPLE for VRPN version @CONFIG_VERSION@

################################################################################
################################################################################
# This file provides comments and examples for the vrpn.cfg file that is read
# by the vrpn_server application when it starts up. This is a generic server
# application that can start up many but maybe not all servers.
#
# This has sample lines for a vrpn.cfg file.  If you get a new device working,
# add a line for it here.  DO NOT remove lines from this file (unless
# devices are declared obsolete) - just change the actual vrpn.cfg to match
# your application.
#
# All examples in the file are preceded by comment characters (#). To actually
# use one of these examples, remove that character from the beginning of all the
# examples that you want to use, and edit those lines to suit your environment.
################################################################################

################################################################################
# NULL Tracker. This is a "device" that reports the Identity transformation for
# each of its sensors at the specified rate. It can be used to verify connections
# are working and for other tests of VRPN. There are three arguments:
#	char	name_of_this_device[]
#	int	number_of_sensors
#	float	rate_at_which_to_report_updates

#vrpn_Tracker_NULL	Tracker0	2	2.0

################################################################################
# Example Button server. This is a "device" that reports on and off for
# each of its buttons at the specified rate. It can be used to verify connections
# are working and for other tests of VRPN. There are three arguments:
#	char	name_of_this_device[]
#	int	number_of_buttons
#	float	rate_at_which_the_buttons_toggle		(transitions/second)

#vrpn_Button_Example	Button0	2	2.0

################################################################################
# Example Dial server. This is a "device" that reports constant rotations for
# each of its dials at the specified rate. It can be used to verify connections
# are working and for other tests of VRPN. There are four arguments:
#	char	name_of_this_device[]
#	int	number_of_dials
#	float	rate_at_which_the_dials_spin		(revolutions/second)
#	float	rate_at_which_to_report_updates		(updates/second)

#vrpn_Dial_Example	Dial0	2	2.0	10.0

################################################################################
# Flock-of-birds Tracker. Runs an Ascension Flock of Birds tracker that is
# attached to a serial port on this machine. Note that there is another driver
# (listed below) that runs the Flock when each sensor is connected to its own
# serial line. Arguments:
#   char    name_of_this_device[]
#   int	    number_of_sensors
#   char    name_of_serial_device[]
#   int	    baud_rate_of_serial_device
#   int     invert_quaternion (0 = no, 1 = yes)
#   char    useERT  (OPTIONAL; defaults to yes)
#   char[2] active_hemisphere (OPTIONAL; defaults to +z)
#
# NOTE: for useERT: use nothing, y or Y if you have an extended range
# transmitter, use N or n if not (added by David Nahon for Virtools
# VRPack/SAS Cube.
# NOTE: The "invert_quaternion" parameter was added because there was a
# conflict between the code that had been around since VRPN started and
# the Flock documentation -- it looks like most people had been using the
# Flock in the "wrong" hemisphere, which inverted the orientation relative
# to the position.  The old behavior is obtained by specifying "1".  Not
# inverting it is specified using "0".
# NOTE: active hemisphere is one of "+x", "-x", "+y", "-y", "+z", "-z"
# If "active_hemisphere" is not specified, it defaults to +z.


#vrpn_Tracker_Flock	Tracker0	4	/dev/ttyS0	115200	1

# If you have to FOB, with no Extended Range ctrler/transmitter, on Windows,
# with -x as the active hemisphere, use

#vrpn_Tracker_Flock	Tracker0	2	COM1	38400	1	N  -x

# Watch: be sure that the serial baud rate dip switches (the 3 on the left)
# of your master flock are properly set.
# You should try baud rates like 38400 before trying to go higher
# In normal address mode - less than 14 fob units - your switch should be:
# 0 1 2 3 4 5 6 7
# 0 0 1	X X X X 0 	2400
# 0 1 0	X X X X 0	4800
# 0 1 1	X X X X 0	9600
# 1 0 0	X X X X 0	19200
# 1 0 1	X X X X 0	38400
# 1 1 0	X X X X 0	57600
# 1 1 1	X X X X 0	115200
#
# X X X X are used for coding the FOB address, they must be set correctly,
# even if you are only using 1 unit (standalone mode)
# the settings should be (in normal address mode):
# 3 4 5 6
# 0 0 0 1	for the first unit
# 0 0 1 0	for the second unit
# 0 0 1 1	for the third
# 0 1 0 0	for the fourth
# 0 1 0 1	for the fifth
# ...
#
############################################################################
# WATCH WATCH WATCH WATCH WATCH WATCH WATCH WATCH WATCH WATCH WATCH WATCH
###################
#
# On windows at least, it might be necessary to cut your serial cable so as
# to only have Transmit, Receive and Ground pins. Even if CBIRDS or WINBIRDS
# are fine with a cable, it doesn't mean that this cable will please vrpn.
# This limitation should have been fixed with version 06.05.
#
###################

################################################################################
# Flock-of-birds in parallel Tracker. Runs an Ascension Flock of Birds tracker
# that has its source and each sensor plugged into its own serial port on this
# machine (perhaps through a Cyclades multi-port serial card). This mode of
# operation increases the throughput and decreases the latency of tracker reports.
# The arguments match those of the Flock-of-birds tracker from above, with the
# addition of the name of the serial ports for each of the sensors added at the
# end. Arguments (all on the same line):
#	char	name_of_this_device[]
#	int	number_of_sensors
#	char	name_of_serial_device_for_controller[]
#	int	baud_rate_of_serial_device
#	int   invert_quaternion (0 = no, 1 = yes)
#	[one for each sensor]	char	name_of_serial_device_for_sensor[]
#
# NOTE: The "invert_quaternion" parameter was added because there was a
# conflict between the code that had been around since VRPN started and
# the Flock documentation -- it looks like most people had been using the
# Flock in the "wrong" hemisphere, which inverted the orientation relative
# to the position.  The old behavior is obtained by specifying "1".  Not
# inverting it is specified using "0".

#vrpn_Tracker_Flock_Parallel	Tracker0	4	/dev/ttyC4	115200	1	/dev/ttyC0 /dev/ttyC1 /dev/ttyC2 /dev/ttyC3
#vrpn_Tracker_Flock_Parallel	Tracker0	2	COM1	115200	1	COM2 COM3

################################################################################
# Fastrak Tracker. Runs a Polhemus Fastrak tracker that is attached to a serial
# port on this machine. This driver will also run an InterSense IS600 or IS900
# tracker, but you will want to include extra initialization code (as described
# below) to set up the ultrasonic pip information, wand devices, stylus devices
# and so forth.  Arguments that go on the first line:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device
#
# It is possible to add additional commands that will be sent to the tracker
# by putting the backslash character (\) at the end of the config line. This
# will cause the following line to be read in and sent to the Fastrak during
# the reset routine. You can add additional lines by putting a slash at the
# end of each command line but the last. Each line will be sent to the Fastrak
# with a newline at the end of it. If a line starts with an asterisk (*), then
# it is treated as a line telling how long to sleep, with the integer number of
# seconds following the *.
#
# If one or more sensors on the Fastrak have a stylus button on them, use
# the "FTStylus" command after the reset command lines (if any).  There should
# be a front-slash "/" character at the end of the line before the FTStylus
# command.  The command takes two arguments: the name of the button device
# that will report the buttons and the sensor number to which the button is
# attached (the first sensor is sensor 0).
#
# Commands to add Joysticks (2 buttons) or Wands (5 buttons and 2 analogs) to
# the various sensors on the Isense900 are done by adding Stylus and
# Wand command lines after the reset command lines.  Each of these lines
# takes two arguments: the name of the button (for Stylus) or button and
# analog (for Wand) servers, and the sensor number (starting from 0).  The
# Wand line takes eight additional parameters, which specify the scaling
# and clipping behavior of the two directions on the analog joystick.  Each
# set of for is the min, lowzero, hizero, and max values: these are mapped
# to -1, 0,0, and 1 (all values between lowzero and hizero are mapped to 0).
# Start with these at -1,0,0,1 and use the 'printcereal' program or some other
# method to read them and see what the range of acheivable values is.  Then,
# set them to slightly conservative values so that the whole range is covered
# and the analogs will report zero when the joystick is centered. The
# presence of these lines is indicated by placing them after any additional
# reset command lines, by ending the line preceding them with the front slash
# "/" character.
#
# Remember that the "remote" button object is not the same as the the tracking
# device, so be sure to use a remote button object that connects to the button
# rather than the tracker.  The button device name is defined on the stylus or
# wand line in the config file, and should not be the same as the tracker.  In
# the case described by the example configuration below, if the name of the
# machine running the server is "myis900server" you would connect to the tracker
# as "Isense900@myis900server" and to the buttons on the stylus as
# "Stylus0@myis900server":
#
# Note that this frontslash and backslash-notation can only be used for the
# Fastrak/Isense tracker, not to extend the line for any other type of device
# listed in this configuration file.

# Vanilla Fastrak on on a Unix box
#vrpn_Tracker_Fastrak	Fastrak0	/dev/ttyS0	19200

# Fastrak with a stylus on sensor zero on a Windows box
#vrpn_Tracker_Fastrak	Tracker0	COM1	115200 /
#FTStylus Stylus0 0

# IS600 and its pip settings
#vrpn_Tracker_Fastrak	Isense600	/dev/ttyS0	19200 \
#MCc\
#*5\
#MCM1,1,0.0900,0.0000,-0.2210,0.00,0.00,-1.00,89\
#MCM1,2,-0.0566,0.0000,-0.2210,0.00,0.00,-1.00,87\
#MCM2,1,0.0900,0.0000,-0.2210,0.00,0.00,-1.00,66\
#MCM2,2,-0.0566,0.0000,-0.2210,0.00,0.00,-1.00,71\
#MCM3,1,0.1237,-0.0762,-0.0424,0.00,0.00,-1.00,82\
#MCM3,2,0.1237,0.0762,-0.0424,0.00,0.00,-1.00,77\
#MCe\
#*10

# IS900 with a wand on the first sensor and a stylus on the third:
#vrpn_Tracker_Fastrak	Isense900	COM1	115200 /
#Wand		Wand0		0	-1.0 0.0 0.0 1.0  -1.0 0.0 0.0 1.0 /
#Stylus	Stylus0	2

################################################################################
# Isotrak Tracker. Runs a Polhemus Isotrak tracker that is attached to a serial
# port on this machine. Arguments that go on the first line:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device
#
# It is possible to add additional commands that will be sent to the tracker
# by putting the backslash character (\) at the end of the config line. This
# will cause the following line to be read in and sent to the Isotrak during
# the reset routine. You can add additional lines by putting a slash at the
# end of each command line but the last. Each line will be sent to the Isotrak
# with a newline at the end of it. If a line starts with an asterisk (*), then
# it is treated as a line telling how long to sleep, with the integer number of
# seconds following the *.

#vrpn_Tracker_Isotrak	TrackerIsotrak	/dev/ttyS0	115200 \
#H1,0,1,0

################################################################################
# Liberty Tracker. Runs a Polhemus Liberty tracker that is attached to a serial
# port (perhaps a USB-to-RS232 adapter) on this machine.  Arguments that go on
# the first line.
#	char	name_of_this_device[]
#	char	name_of_serial_or_usb_device[]
#	int	baud_rate_of_serial_device (not used when the device is USB)
#	int	number_of_chars_in_whoami_response (optional)
#
# It is possible to add additional commands that will be sent to the tracker
# by putting the backslash character (\) at the end of the config line. This
# will cause the following line to be read in and sent to the Liberty during
# the reset routine. You can add additional lines by putting a slash at the
# end of each command line but the last. Each line will be sent to the Fastrak
# with a newline at the end of it. If a line starts with an asterisk (*), then
# it is treated as a line telling how long to sleep, with the integer number of
# seconds following the *.
#
# If one or more sensors on the Liberty have a stylus button on them, use
# the "Stylus" command after the reset command lines (if any).  There should
# be a front-slash "/" character at the end of the line before the Stylus
# command.  The command takes two arguments: the name of the button device
# that will report the buttons and the sensor number to which the button is
# attached (the first sensor is sensor 0).
#

# -------------------------------------------
# Example when Liberty is attached via USB
# The BAUD Rate is needed, although it is not used

#vrpn_Tracker_Liberty	Liberty	/dev/usb/ttyUSB0	115200

#--------------------------------------------
# Example when Liberty is attached via Serial

#vrpn_Tracker_Liberty   Liberty /dev/ttyS0        115200

#--------------------------------------------
# Example when Liberty is attached via Serial with a non-standard whoami length

#vrpn_Tracker_Liberty   Liberty /dev/ttyS0        115200	247

#--------------------------------------------
# Liberty attached via Serial with styluses on sensors zero and three
#vrpn_Tracker_Liberty	Tracker0	/dev/ttyS0	115200 /
#Stylus Stylus0 0 /
#Stylus Stylus1 3

################################################################################
# High Speed Liberty Latus Tracker. Runs a Polhemus Liberty Latus tracker that 
# is attached to a USB port on this machine.  Arguments that go on the first line
#	char	name_of_this_device[]
#       int     number_of_markers_to_detect
#	int	baud_rate_of_usb_device
#	int	number_of_chars_in_whoami_response (optional)
#
# It is possible to add additional commands that will be sent to the tracker
# by putting the backslash character (\) at the end of the config line. This
# will cause the following line to be read in and sent to the Liberty during
# the reset routine. You can add additional lines by putting a slash at the
# end of each command line but the last. Each line will be sent to the Fastrak
# with a newline at the end of it. If a line starts with an asterisk (*), then
# it is treated as a line telling how long to sleep, with the integer number of
# seconds following the *. 

# -------------------------------------------
# Example when Liberty Latus is attached via USB
# The BAUD Rate is needed, although it is not used

#vrpn_Tracker_LibertyHS   LibertyHS   3   115200

################################################################################
# InterSense tracker using the Intersense-provided library to communicate
# with the tracker.  This device type is not compiled by default, since it uses
# a proprietary library.  However, you can get it to compile by defining
# VRPN_INCLUDE_INTERSENSE when compiling.  Note that the Fastrak driver will
# run IS-600 and IS-900 trackers without the proprietary library, so you might
# try that as well.
#
# You can include extra initialization code (as described
# below) to set up the ultrasonic pip information, wand devices, stylus devices
# and so forth.  Arguments that go on the first line:
#       char    name_of_this_device[]
#       char    name_of_serial_device[] - this can be COM1-4 or AUTO
#                                     AUTO will automatically find USB and
#                                     serial trackers. Use COM1-4 only if you
#                                     have more than one serial tracker.
#                                     You should use COM1-4 on unix as well,
#                                     as these just tell the isense library
#                                     to look in serial port 1-4.
#                                     I guess you can't have >1 USB trackers.
#     char "IS900time"		- use the IS900 timestamps (optional)
#     char "ResetAtStartup"	- resets all boresight and heading, on intertrax, 
#			          equivalent to push the reset button
#
# It is possible to add additional commands that will be sent to the tracker
# by putting the backslash character (\) at the end of the config line. This
# will cause the following line to be read in and sent to the InterSense during
# the reset routine. You can add additional lines by putting a slash at the
# end of each command line but the last. Each line will be sent to the InterSense
# with a newline at the end of it. If a line starts with an asterisk (*), then
# it is treated as a line telling how long to sleep, with the integer number of
# seconds following the *.
#
# Commands to add Joysticks (2 buttons) or Wands (5 buttons and 2 analogs) to
# the various sensors on the Isense900 are done by adding Stylus and
# Wand command lines after the reset command lines.  Each of these lines
# takes two arguments: the name of the button (for Stylus) or button and
# analog (for Wand) servers, and the sensor number (starting from 0).  The
# Wand line takes eight additional parameters, which specify the scaling
# and clipping behavior of the two directions on the analog joystick. Each
# set of for is the min, lowzero, hizero, and max values: these are mapped
# to -1, 0,0, and 1 (all values between lowzero and hizero are mapped to 0).
# Start with these at -1,0,0,1 and use the 'printcereal' program or some other
# method to read them and see what the range of acheivable values is. Then,
# set them to slightly conservative values so that the whole range is covered
# and the analogs will report zero when the joystick is centered. The
# presence of these lines is indicated by placing them after any additional
# reset command lines, by ending the line preceding them with the front slash
# "/" character.
#
# Remember that the "remote" button object is not the same as the the tracking
# device, so be sure to use a remote button object that connects to the button
# rather than the tracker.  The button device name is defined on the stylus or
# wand line in the config file, and should not be the same as the tracker. In
# the case described by the example configuration below, if the name of the
# machine running the server is "myis900server" you would connect to the tracker
# as "Isense900@myis900server" and to the buttons on the stylus as
# "Stylus0@myis900server":
#
# Note that this frontslash and backslash-notation can only be used for the
# Fastrak and InterSense tracker, not to extend the line for any other
# type of device
# listed in this configuration file.
#
# Note that this driver expects the device to be set to output centimeters, and will convert 
# the positions to meters. It is recommanded to permanently set the units in the eeprom of your device.
# If this is not possible, you should add in this file the "u" reset command so as to have vrpn
# tell your device to use centimeters
#
#Vanilla InterSense
#vrpn_Tracker_InterSense Tracker0 AUTO IS900time

# Vanilla InterSense using IS900 timing, with wand in port B (and possibly head tracker in port A)
#vrpn_Tracker_InterSense Tracker0 AUTO IS900time /
#Wand            Wand0           1       -1.0 0.0 0.0 1.0  -1.0 0.0 0.0 1.0

# IS600 and its pip settings
#vrpn_Tracker_InterSense        Isense600       COM1 \
#MCc\
#*5\
#MCM1,1,0.0900,0.0000,-0.2210,0.00,0.00,-1.00,89\
#MCM1,2,-0.0566,0.0000,-0.2210,0.00,0.00,-1.00,87\
#MCM2,1,0.0900,0.0000,-0.2210,0.00,0.00,-1.00,66\
#MCM2,2,-0.0566,0.0000,-0.2210,0.00,0.00,-1.00,71\
#MCM3,1,0.1237,-0.0762,-0.0424,0.00,0.00,-1.00,82\
#MCM3,2,0.1237,0.0762,-0.0424,0.00,0.00,-1.00,77\
#MCe\
#*10

# IS900 with a wand on the first sensor and a stylus on the third:
#vrpn_Tracker_InterSense        Isense900       COM1 /
#Wand           Wand0           0       -1.0 0.0 0.0 1.0  -1.0 0.0 0.0 1.0 /
#Stylus Stylus0 2

# Intertrax2 on USB, With automatic reset at startup
#vrpn_Tracker_InterSense        Tracker0       AUTO  ResetAtStartup

################################################################################
# Dynasight Tracker. Runs an Origin System's DynaSight tracker connected to a
# serial port on this machine. arguments:
#	char	name_of_this_device[]
#	int	number_of_sensors
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device

#vrpn_Tracker_Dyna	Tracker0	1	/dev/ttyS0	19200

#vrpn_Tracker_Dyna	Tracker0	1	COM1		19200

################################################################################
# Crossbow Tracker. Runs a Crossbow Technology RGA300-series tracker that is
# attached to a serial port on this machine. There are four arguments:
#       char    name_of_this_device[]
#       char    name_of_serial_device[]
#       int             baud_rate_of_serial_device (should be 38400)
#       float   linear_acceleration_sensitivity (Gs; default is 2.0)
#       float   angular_rate_sensitivity (degrees per second; default is 100)

#vrpn_Tracker_Crossbow  Tracker0        COM1:   38400   2.0     100

###############################################################################
# 3d Microscribe is a mechanical tracker the nesseccary params are
# name  port baudrate
# additional params are offsetx offsety offsetz scale
# offsets are in meters.  Scale is an abomination in VRPN; all
# trackers report in meters.
#

#vrpn_3DMicroscribe Microscribe COM1 19200 0.3 -0.1 -0.2 1

################################################################################
# Serial 5DT glove with 16 sensors.  This driver reports the 16 channels as analog
# devices.  If you want to treat them as buttons, then also add the entry
# for the vrpn_Button_5DT_Server below, connecting it to the output of this
# server.
#
# This server does not work with the previous version of the glove.
# For other variations of 5DT datagloves, see vrpn_5dt and vrpn_Analog_5dtUSB
#
#  arguments:
#       char    name_of_this_device[]
#       char    name_of_serial_device[]
#       int     baud_rate_of_serial_device

#vrpn_5dt16    glove_5dt16     COM1    19200

################################################################################
#
# Use the 5dtglove16 as button device.  Use in conjunction with the vrpn_5dt16
# device above to turn the analog reports into button press/release when the
# sensors cross the threshold.
#
# arguments:
#       char name_of_this_device[]
#       char name_of_the_glove device[]
#       double threshold_toggle_point_between_pressed_and_unpressed[16]

#vrpn_Button_5DT_Server glove_5dt_button glove_5dt16 1794 2171 2110 2610 1707 2673 2459 1493 3029 2301 1936 3007 2302 1635 0 0

################################################################################
# AnalogFly Tracker. This is a tracker that is intended to be used on top of
# a joystick or motion tracker of some kind to turn it into a moving or flying
# device. It could be used on top of any analog device, in fact.
#   This device basically takes in analog signals and puts out transformation
# matrices. It should supercede the JoyFly tracker, since it is more general.
#   There are two kinds of JoyFly's: absolute ones and differential ones.  For
# absolute ones, the analog value is mapped directly to position or orientation
# on each axis.  For differential ones, the values are used to create a
# "change" matrix that is applied once per interval, accumulating changes as
# it goes; this enables the user to "fly" along by holding a joystick forward,
# for example.
#   One analog channel is associated with each axis (X, Y, Z) and rotation about
# each axis (RX, RY, RZ). For each axis, the value is converted to a position
# (meters) or speed (meters/second) for absolute trackers; or into an
# orientation (revolutions) or angular velocity (revolutions/second) by first
# subtracting an offset, then thresholding it to see if it is far enough from
# zero, then (if it is) scaling it and taking it to a power (to allow nonlinear
# speedup as the stick is pushed far from center).
#   A button can be associated with a reset function, which will take the
# device back to center (identity transformation). The device will also recenter
# when the first connection is made to the server it is running on. (Centering
# has no effect on absolute AnalogFlys).
#   A button can be associated with a clutch function, which will mean that
# the device will not move unless the clutch is pressed, so you can use it
# like a mouse and continue to move by pulling to the right with the button
# down and then to the left with the button up.  For differential analogflys,
# clutching makes the tracker not move unless the button is pressed.  For
# absolute ones, it only moves when the button is pressed and the mouse is
# moving; it offsets to enable long-range motions in a finite tracking area,
# as with a mouse.
#   Any axis or the reset button can be disabled by setting the name of its
# associated device to the string "NULL".
#   Note that you could have multiple of these devices running simultaneously,
# each with a different name and interaction metaphor. The user could then
# connect to their favorite one. Arguments:
#	char  name_of_this_device[]
#	float update_rate_to_send_tracker_reports
#	char  type[] = "absolute" or "differential"
#	[six lines follow, one for X Y Z RX RY RZ, each with:
#		char	axis_name[]			(X Y Z RX RY RZ in that order)
#		char	name_of_analog_device[]		(start with * for local)
#		int	channel_of_analog_device
#		float offset
#		float	threshold
#		float	scale
#		float	power
#	]
#	[New line to describe reset button, with:
#		char	"RESET"
#		char	name_of_button_device[]		(start with * for local)
#		int	which_button_to_use
#	]
#	[New line to describe clutch button, with:
#		char	"CLUTCH"
#		char	name_of_button_device[]		(start with * for local)
#		int	which_button_to_use
#	]
#   [New line to indicate use of world frame for translation and rotation,
#   instead of local frame. Useful for a simulated wand when doing desktop
#   testing of immersive apps - easier to keep under control.
#		char	"WORLDFRAME"
#	]

#vrpn_Tracker_AnalogFly Tracker0 60.0 absolute
#X  *Mouse0 0 0.5 0.0 2.0 1.0
#Y  *Mouse0 1 0.5 0.0 2.0 1.0
#Z  NULL 2 0.0 0.0 1.0 1.0
#RX NULL 3 0.0 0.0 1.0 1.0
#RY NULL 4 0.0 0.0 1.0 1.0
#RZ NULL 5 0.0 0.0 1.0 1.0
#RESET NULL 0
#CLUTCH *Mouse0 0

#vrpn_Tracker_AnalogFly	Tracker0	60.0	absolute
#X	*CerealBox0	4	0.0	0.021	1.0	1.0
#Y	*CerealBox0	5	0.0	0.021	1.0	1.0
#Z	*CerealBox0	6	0.0	0.021	3.0	1.0
#RX	*CerealBox0	0	0.0	0.021	1.0	1.0
#RY	*CerealBox0	1	0.0	0.021	1.0	1.0
#RZ	*CerealBox0	2	0.0	0.021	3.0	1.0
#RESET	*CerealBox	3
#CLUTCH	NULL 0

#vrpn_Tracker_AnalogFly	Tracker0	60.0	differential
#X	*Magellan0	0	0.0	0.0	2.0	1.0
#Y	*Magellan0	1	0.0	0.0	2.0	1.0
#Z	*Magellan0	2	0.0	0.0	2.0	1.0
#RX	*Magellan0	3	0.0	0.0	2.0	1.0
#RY	*Magellan0	4	0.0	0.0	2.0	1.0
#RZ	*Magellan0	5	0.0	0.0	2.0	1.0
#RESET	NULL	0
#CLUTCH	NULL 0

# For a good simulated wand for testing VR Juggler applications with a SpaceMouse:
#vrpn_Tracker_AnalogFly	Tracker0	60.0	differential
#X	*Magellan0	0	0.0	0.0	20.0	    1
#Y	*Magellan0	1	0.0	0.0	20.0	    1
#Z	*Magellan0	2	0.0	0.0	20.0	    1
#RX	*Magellan0	3	0.0	0.01	-5	1.0
#RY	*Magellan0	4	0.0	0.01	-5	1.0
#RZ	*Magellan0	5	0.0	0.01	-5	1.0
#RESET	NULL	0
#CLUTCH	NULL 0
#WORLDFRAME

#vrpn_Tracker_AnalogFly	Tracker0	60.0	absolute
#X	NULL		0	0.0	0.0	1.0	1.0
#Y	NULL		0	0.0	0.0	1.0	1.0
#Z	NULL		0	0.0	0.0	1.0	1.0
#RX	*Radamec0	1	0.0	0.0	-0.0027777777	1.0
#RY	NULL		0	0.0	0.0	1.0	1.0
#RZ	*Radamec0	0	0.0	0.0	0.0027777777	1.0
#RESET	NULL	0
#CLUTCH	NULL 0

#vrpn_Tracker_AnalogFly	Tracker0	60.0	absolute
#X	*Joystick0	0	0.0	0.0	1.0	1.0
#Y	*Joystick0	1	0.0	0.0	-1.0	1.0
#Z	*Joystick0	6	0.0	0.0	1.0	1.0
#RX	NULL		3	0.0	0.0	1.0	1.0
#RY	NULL		4	0.0	0.0	1.0	1.0
#RZ	*Joystick0	5	0.0	0.0	0.5	1.0
#RESET	NULL	0
#CLUTCH	NULL 0

# Using a joystick to emulate a Phantom for the
# nanoManipulator, the throttle maps to Z.
#vrpn_Tracker_AnalogFly	Phantom	60.0	absolute
#X	*Phantom	0	0.0	0.0	0.125	1.0
#Y	*Phantom	1	0.0	0.0  -0.125	1.0
#Z	*Phantom	6	0.0	0.0	0.25	1.0
#RX	NULL		3	0.0	0.0	1.0	1.0
#RY	NULL		4	0.0	0.0	1.0	1.0
#RZ	*Phantom	5	0.0	0.0	0.06	1.0
#RESET	NULL	0
#CLUTCH	NULL 0

# For DTU/MIC optical nanoHand stage motion, moving over full 300 micron range
# of motion, using the Logitech joystick for the analog
# server and the tracker_to_poser program.
#vrpn_Tracker_AnalogFly	Tracker0	60.0	absolute
#X	*Joystick0	0	-0.03	0.0	2.53	1.0
#Y	*Joystick0	1	-0.04	0.0	2.53	1.0
#Z	*Joystick0	6	-0.10	0.0	-1.75	1.0
#RX	NULL		3	0.0	0.0	1.0	1.0
#RY	NULL		4	0.0	0.0	1.0	1.0
#RZ	*Joystick0	5	0.0	0.0	0.5	1.0
#RESET	NULL	0
#CLUTCH	NULL 0

# To drive a Tektronix 4662 full range (Z, RZ ignored)
#vrpn_Tracker_AnalogFly	Tracker0	60.0	absolute
#X	*Joystick0	0	-1.0	0.0	0.19	1.0
#Y	*Joystick0	1	1.0	0.0	-0.13	1.0
#Z	*Joystick0	6	0.0	0.0	1.0	1.0
#RX	NULL		3	0.0	0.0	1.0	1.0
#RY	NULL		4	0.0	0.0	1.0	1.0
#RZ	*Joystick0	5	0.0	0.0	0.5	1.0
#RESET	NULL	0
#CLUTCH	NULL 0

# For UNC Mad City Labs stage motion, moving over full 100 micron range
# of motion, using the Microsoft FF joystick for the analog
# server and the tracker_to_poser program.
#vrpn_Tracker_AnalogFly	Tracker0	60.0	absolute
#X	*Joystick0	0	-1	0.0	50	1.0
#Y	*Joystick0	1	-1	0.0	50	1.0
#Z	*Joystick0	6	-1	0.0	50	1.0
#RX	NULL		3	0.0	0.0	1.0	1.0
#RY	NULL		4	0.0	0.0	1.0	1.0
#RZ	*Joystick0	5	0.0	0.0	0.5	1.0
#RESET	NULL	0
#CLUTCH	NULL 0

# For Artemis or Hercules (mad-city-labs) stages
# Maps 0-10 from the voltage into the range 0-100 microns.
#vrpn_Tracker_AnalogFly	StageTracker	60.0	absolute
#X	*MCLXYZIN	4	0	0.0	10	1.0
#Y	*MCLXYZIN	5	0	0.0	10	1.0
#Z	*MCLXYZIN	6	0	0.0	10	1.0
#RX	NULL		3	0.0	0.0	1.0	1.0
#RY	NULL		4	0.0	0.0	1.0	1.0
#RZ	NULL		5	0.0	0.0	1.0	1.0
#RESET	NULL	0
#CLUTCH	NULL 0

################################################################################
# XXX This device is superceded by the more-general vrpn_Tracker_AnalogFly.
# JoyFly Tracker. A vrpn_Tracker that translates the vrpn_Joystick into
# Walkthrough- convention tracker reports. This is part of a two-part setup
# that allows you to use a joystick as a flying device. First, a joystick
# device has to be created (named joybox in our example) that will produce
# the analog inputs that the JoyFly tracker uses to determine the transformation.
# Then, the JoyFly device needs to be started and will listen to the device
# and produce tracker reports. If these are both run on the same server, then
# the JoyFly needs to use the "server" connection to hear from the Joystick
# device, which is indicated by placing a '*' in front of the name of the
# joystick device that it is to use. If the joystick device is remote from
# this server, then the full name of it should be used (joystick@foo.cs.unc.edu).
# XXX This device is superceded by the more-general vrpn_Tracker_AnalogFly
# Arguments:
#	char	name_of_this_device[]
#	char	source_joystick_name[]  (Start with * for one sharing a connection)
#	char	joystick_configuration_file_name[]

#vrpn_JoyFly walk-joybox *joybox vrpn_Joyfly.cfg

################################################################################
# ButtonFly Tracker. This is a tracker that is intended to be used on top of
# a Global Haptics Orb or other buttond device to turn it into a moving or
# flying device.  It basically takes in button signals and puts out
# transformation matrices.
#   There are two kinds of Buttons: absolute ones and differential ones.  For
# absolute ones, pressing it causes the position or orientation associated with
# it to be stored directly into the transformation.  This enables the user to
# "teleport" to given locations by pressing buttons.  For differential ones,
# the position or orientation are treated as deltas and are used to create a
# "change" matrix that is applied once per interval, accumulating changes as
# it goes; this enables the user to "fly" along by holding a button down,
# for example.
#   Each button is associated with either a position (meters) or speed
# (meters/second) for absolute buttons; or an orientation (revolutions)
# or angular velocity (revolutions/second).
#   An analog channel can be associated with a scale function that scales the
# velocity or angular velocity terms uniformly.  The entry specifies an
# offset to be applied to the analog channel, a scale to be applied to it,
# and a power to which the result should be taken; the end result is used
# to scale all velocity or angular velocity terms.  This channel has no
# effect on the effects of absolute buttons.
#   The device will recenter (set itself to the identity transform) when the
# first connection is made to the server it is running on.
#   Note that you could have multiple of these devices running simultaneously,
# each with a different name and interaction metaphor. The user could then
# connect to their favorite one. Arguments:
#	char  name_of_this_device[]
#	float update_rate_to_send_tracker_reports
#	[one or more lines follow, each of one of two types
#	    (1)	char	[] = "absolute"
#		char	name_of_button_device[] (start with * for local)
#		int	which_button_on_device
#		float	X_to_translate_to
#		float	Y_to_translate_to
#		float	Z_to_translate_to
#		float	rotation_about_X
#		float	rotation_about_Y
#		float	rotation_about_Z
#	    (2)	char	[] = "differential"
#		char	name_of_button_device[] (start with * for local)
#		int	which_button_on_device
#		float	X_translation_meters_per_second
#		float	Y_translation_meters_per_second
#		float	Z_translation_meters_per_second
#		float	spin_about_X_revolutions_per_second
#		float	spin_about_Y_revolutions_per_second
#		float	spin_about_Z_revolutions_per_second
#	]
#	[An optional line describing an analog to scale the velocity
#		char	[] = "vel_scale"
#		char	name_of_button_device[] (start with * for local)
#		int	which_button_on_device
#		float	offset
#		float	scale
#		float	power
#	]
#	[An optional line describing an analog to scale the rotation
#		char	[] = "rot_scale"
#		char	name_of_button_device[] (start with * for local)
#		int	which_button_on_device
#		float	offset
#		float	scale
#		float	power
#	]
#	[one more line, consisting of the word "end"]
#   Note that the same button can cause more than one action to take place,
# and the same analog can cause scaling of both the velocity and rotation.

# This example for a Global Haptics Orb pushes the transformation away
# from the button that is pressed
# for all of the standard buttons.  It rotates around the Y axis when the
# rocker switch is rocked up and down.  It resets to the origin when one
# of the pushbuttons is pressed.  Both the velocity and angular velocity
# are controlled by the thumbwheel.

#vrpn_Tracker_ButtonFly	Tracker0	60.0
#differential	*Orb0	0	0 1 0	0 0 0
#differential	*Orb0	1	0.707 0.707 0	0 0 0
#differential	*Orb0	2	1 0 0	0 0 0
#differential	*Orb0	3	0.707 -0.707 0	0 0 0
#differential	*Orb0	4	0 -1 0	0 0 0
#differential	*Orb0	5	-0.707 -0.707 0	0 0 0
#differential	*Orb0	6	-1 0 0	0 0 0
#differential	*Orb0	7	-0.707 0.707 0	0 0 0
#differential	*Orb0	8	0 0.707 -0.707	0 0 0
#differential	*Orb0	9	0.577 0.577 -0.577	0 0 0
#differential	*Orb0	10	0.707 0 -0.707	0 0 0
#differential	*Orb0	11	0.577 -0.577 -0.577	0 0 0
#differential	*Orb0	12	0 -0.707 -0.707	0 0 0
#differential	*Orb0	13	-0.577 -0.577 -0.577	0 0 0
#differential	*Orb0	14	-0.707 0 -0.707	0 0 0
#differential	*Orb0	15	-0.577 0.577 -0.577	0 0 0
#differential	*Orb0	16	0 0.707 0.707	0 0 0
#differential	*Orb0	17	0.577 0.577 0.577	0 0 0
#differential	*Orb0	18	0.707 0 0.707	0 0 0
#differential	*Orb0	19	0.577 -0.577 0.577	0 0 0
#differential	*Orb0	20	0 -0.707 0.707	0 0 0
#differential	*Orb0	21	-0.577 -0.577 0.577	0 0 0
#differential	*Orb0	22	-0.707 0 0.707	0 0 0
#differential	*Orb0	23	-0.577 0.577 0.577	0 0 0
#differential	*Orb0	24	0 0 -1	0 0 0
#differential	*Orb0	25	0 0 1	0 0 0
#differential	*Orb0	28	0 0 0	0 -0.1 0
#differential	*Orb0	29	0 0 0	0 0.1 0
#absolute	*Orb0	27	0 0 0	0 0 0
#vel_scale	*Orb0	0	-1.0 0.5 1.0
#rot_scale	*Orb0	0	-1.0 0.5 1.0
#end

################################################################################
# 3Space Tracker. Runs a Polhemus 3Space (not Fastrak) tracker that is attached
# to a serial port on this machine.  Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device

#vrpn_Tracker_3Space	Tracker0	/dev/ttyS0	19200

################################################################################
# Logitech 3DMouse tracker attached to a serial port on this machine.
#  Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device
#	int	filtering_count (this parameter is optional)

#vrpn_Tracker_3DMouse	Tracker0	/dev/ttyS0	19200

################################################################################
#  NDI Polaris Spectra or Vectra, attached to a serial or USB port
# This server works with the NDI Polaris Spectra and Polaris Vectra
# trackers.  It doesn't work with the Optitrak or Aurora.  It only
# handles rigid bodies made from passive sphere markers, and does
# not yet support active led markers nor single "stray" passive 
# spheres.
#
# Each vrpn "sensor" is a single rigid body (or "tool" in NDI
# terminology), which consists of 3 or more passive spheres in a 
# particular geometric arrangement. In order to define a custom
# rigid body (one that didn't come from NDI), you must use the NDI
# Architect software. That software produces .rom files for each 
# rigid body. This vrpn tracker class will load those files during 
# initialization.
#
# Before configuring the vrpn server here, you should first run
# the NDI software to track the rigid bodies using the NDI's 
# interactive GUI. Only after you have configured and tested the
# tracker and rigid bodies to your satisfaction, should you try
# this vrpn server. 
#
# This currently only handles an IR strobe rate of 60Hz, not 
# 20Hz or 30Hz.
#
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	    number of sensors (i.e. num of rigid bodies)  
#
#   char    rigidBody 0's .rom filename
#   char    rigidBody 1's .rom filename
#   char    rigidBody 2's ...

# vrpn_Tracker_NDI_Polaris Tracker0 COM1 2 
# hello.rom 
# ../world.rom

################################################################################
# CerealBox dial/button/analog. Runs a BG Systems CerealBox device that attaches
# to a serial port on this machine. As of VRPN version 04.07, 19200 is the
# only supported baud rate. The driver has been tested on an LV824-F-8e device.
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device
#	int	number_of_buttons_to_read (starting from 0)
#	int	number_of_analogs_to_read
#	int	number_of_encoders_to_read

#vrpn_CerealBox	Cereal0	/dev/cua0	19200	8 8 8

################################################################################
# Magellan button/analog. Runs a Logitech Magellan device that attaches
# to a serial port on this machine. As of VRPN version 04.12, 9600 is the
# only supported baud rate.
#
# The Magellan is also known in some instances as the Magellan SpaceMouse,
# not to be confused with the 3DConnexion SpaceMouse (later version of the
# same product).
# 3DConnexion Magellan/SpaceMouse Plus XT Serial -
#	works with vrpn_Magellan without "altreset" for some.
#	requires "altreset" to avoid lots of beeping at startup for others.
#
# Note that if you want to use the Magellan as a tracking device, you will
# need to run a vrpn_Tracker_AnalogFly device that listens to its analog
# outputs and converts them into tracker reports
#
# John Stone added support for the SpaceBalls in version 06.03, an example
# startup is shown below.
#
# Julien Brisset discovered how to make this work with a slightly older version
# of the Magellan.  If the example Magellan line doesn't work, add 'altreset' to
# the line to use the alternative reset string for the device.
#
# If your Magellan is connected through a usb-serial cable on Mac OS X, use
# /dev/tty.usbserial, on Linux you may want to try /dev/ttyUSB0 instead.
#
# NOTE: You should NOT run the driver that comes with the Magellan, since the
# VRPN driver opens the serial port and communicates with the device directly.
# If the Magellan driver from the manufacturer is running, then VRPN may not
# be able to open the port.
#
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device
#	char	"altreset"   {Optional, for older Magellans}

#vrpn_Magellan	Magellan0	COM1	9600
#vrpn_Magellan	Magellan0	/dev/ttyS0	9600	altreset
#vrpn_Spaceball	Spaceball0	/dev/ttyS0	9600
#vrpn_Magellan	Magellan0	/dev/tty.usbserial	9600	altreset

################################################################################
# NRL Immersion Box dial/button/analog. Runs a Immersion Interface Box device
# attached to a serial port. As of March 28, 2000 code to read the analog and
# angle encoders has not been implemented.  Also, baud rate on many SGI's is
# limited to 38400, but I have run the ibox at 115200 on PCs.
#       char    name_of_this_device[]
#       char    name_of_serial_device[]
#       int     baud_rate_of_serial_device
#       int     number_of_buttons_to_read (i.e. 4 ==> 0,1,2,3)
#       int     number_of_analogs_to_read
#       int     number_of_encoders_to_read

#vrpn_ImmersionBox      ibox    /dev/ttyd2      38400   4 0 0
#vrpn_ImmersionBox      ibox    com1            115200  4 0 0

################################################################################
# Wands button/analog, driver from Brown University. Runs a Wanda device
# attached to a serial port.
#
# Arguments:
#       char    name_of_this_device[]
#       char    name_of_serial_port_to_use[]
#       int     baud_rate_of_serial_device
#	float   minimum_update_rate

#vrpn_Wanda      Wanda    /dev/ttyd2      1200   60.0
#vrpn_Wanda      Wanda    COM2      1200   60.0

################################################################################
# Radamec Serial Position Interface analog. Camera tracker that attaches
# to a serial port on this machine. Note that for normal operation, 38400 is the
# only supported baud rate.
#
# Note that if you want to use the Radamec SPI as a tracking device, you will
# need to run a vrpn_Tracker_AnalogFly device (of the absolute variety)
# that listens to its analog outputs and converts them into tracker reports.
#
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_port[]
#	int	baud_rate_of_serial_port

#vrpn_Radamec_SPI	Analog0	/dev/ttyS16	38400

################################################################################
# Zaber linear positioning element analog/out that attaches
# to a serial port on this machine.
#
# Note that if you want to use the Zaber as a tracking device, you will
# need to run a vrpn_Tracker_AnalogFly device (of the absolute variety)
# that listens to its analog outputs and converts them into tracker reports.
#
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_port[]

#vrpn_Zaber	Analog0	COM1

################################################################################
# Biosciences Tools temperature control unit, analog/out that attaches
# to a serial port on this machine.
#
# This instrument also has a button device that reports whether the
# temperature control is turned on.
#
# Analog channels: (read by client)
#	0	Reading from stage 1 in degrees Celcius
#	1	Reading from bath 1 in degrees Celcius
#	2	Reading external 1 or Setpoint for control in degrees Celcius
#	3	Reading from stage 2 in degrees Celcius
#	4	Reading from bath 2 in degrees Celcius
#	5	Reading external 2 or Setpoint for control in degrees Celcius
# Button channels: (read by client)
#	0	Temperature control is on or off
# Analog_Output channels: (set by client)
#	0	Reference temperature for channel 1
#	1	Reference temperature for channel 2
#	2	Turn temperature control on/off (0 = off, otherwise on)
#
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_port[]
#	float	Temperature to set for channel 1 in degrees Celcius
#	float	Temperature to set for channel 2 in degrees Celcius
#	int	Do we turn on temperature control (0 = no, 1 = yes)

#vrpn_BiosciencesTools	Analog0	COM1 37.0 37.0 0

################################################################################
# IDEA-drive linear positioning element analog that attaches
# to a serial port on this machine.
#
# Note that if you want to use the IDEA as a tracking device, you will
# need to run a vrpn_Tracker_AnalogFly device (of the absolute variety)
# that listens to its analog outputs and converts them into tracker reports.
#
# If the drive does not have a limit switch to calibrate against and you need to
# drive it to one rail to find a zero location, use a nonzero initial_move
# value to cause a move.  To keep it from getting stuck against that limit,
# change the fractional_c_a value to be less than one -- this will lower
# both the current and the acceleration/deceleration by this fraction for
# this initial move.  The location of the device is reset to 0 after the
# move is done.
#
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_port[]
#	int		run_speed_tics_sec
#	int		start_speed_tics_sec
#	int		end_speed_tics_sec
#	int		accel_rate_tics_sec_sec
#	int		decel_rate_tics_sec_sec
#	int		run_current
#	int		hold_current
#	int		accel_current
#	int		decel_current
#	int		delay
#	int		step
#	int		high_limit_index		(-1 for none)
#	int		low_limit_index			(-1 for none)
#	int		output_1_value			(0 for off, 1 for on, -1 for don't change)
#	int		output_2_value			(0 for off, 1 for on, -1 for don't change)
#	int		output_3_value			(0 for off, 1 for on, -1 for don't change)
#	int		output_4_value			(0 for off, 1 for on, -1 for don't change)
#	double	initial_move			(0 for no move)
#	double	fractional_c_a			(Fraction of full current and acceleration)

#vrpn_IDEA	Analog0	COM1 3200 1200 2000 40000 100000 290 0 290 290 50 8 1 -1 1 0 0 0 0 1.0
#vrpn_IDEA	Analog1	COM2 3200 1200 2000 40000 100000 290 0 290 290 50 8 1 -1 1 0 0 0 0 1.0
#vrpn_IDEA	Analog2 COM3 3200 1200 2000 40000 100000 290 0 290 290 50 8 1 -1 1 0 0 0 0 1.0
#vrpn_IDEA	Analog0	/dev/ttyUSB1 3200 1200 2000 40000 100000 290 0 290 290 50 8 -1 -1 1 0 0 0 10000 0.2
#vrpn_IDEA	Analog1	/dev/ttyUSB2 3200 1200 2000 40000 100000 290 0 290 290 50 8 -1 -1 1 0 0 0 10000 0.2
#vrpn_IDEA	Analog2	/dev/ttyUSB3 3200 1200 2000 40000 100000 290 0 290 290 50 8 -1 -1 1 0 0 0 10000 0.2

################################################################################
# SGI Dial and Button box, raw interface. Runs a dial-and-button box from SGI,
# talking to it through the raw serial interface (not using the GL interface
# supplied by SGI). This allows the box to be opened even if there is nobody
# logged on at the console. Note that to use this on an SGI, you will need to
# configure the port as a serial device, not as a button device, to get it to
# run. Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	[list of buttons to treat as toggles]	int	button_to_toggle

#vrpn_raw_SGIBox	Sgibox0	/dev/ttyS0	0 1 2 3

################################################################################
# SGI Dial and Button box, cooked interface. Runs a dial-and-button box from SGI,
# talking to it through the GL interface supplied by SGI. Note that this can
# only be used on an SGI, and the serial port must be configured as a dial/button
# device and the dial/button server from SGI must be running to use it. Arguments:
#	char	name_of_this_device[]
#	[list of buttons to treat as toggles]	int	button_to_toggle

#vrpn_SGIBOX	Sgibox0	1 2 

################################################################################
# UNC Python button device. UNC has developed a custom button input device, which
# is a 5-button controller that attaches to a parallel port and uses the sense
# lines to return the state of the buttons. This runs the device. Note that on
# Windows NT, you need to have installed the GiveIO driver for this code to
# work. It also works on Linux (no extra drivers needed), but on no other
# architecture. Arguments:
#	char	name_of_this_device[]
#	int	parallel_port_to_use_starting_with_1
#	int	hexadecimal_io_base_number (default address used if left off)

#vrpn_Button_Python	Button0	1

################################################################################
# UNC Joystick driver. UNC has developed a custom-build joybox, with 7 analog
# and 2 button inputs (two 3-axis joysticks and a slider, with a button on top
# of each joystick). This will drive one of these devices, which attaches to
# a serial port on this computer. I'm not sure what the baud rate should be;
# David Harrison might know.
# This driver can be used in conjunction with the JoyFly driver to produce a
# tracker that uses the joystick to fly around. Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device
#	float	minimum_update_rate_from_analogs_even_if_they_dont_move

#vrpn_Joystick	Joybox0	/dev/ttyd1	19200	10.0

################################################################################
# Linux Joystick. Interface to the Linux Joystick driver by Vojtech Pavlik
# included in several Linux distributions. The server code has been tested 
# with Linux Joystick driver version 1.2.14. Yet, there is no way how to
# map a typical joystick's zillion buttons and axes on few buttons and axes
# really used. Unfortunately, even joysticks of the same kind can have 
# different button mappings from one to another.
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_joystick_device[]

#vrpn_Joylin	Joylin0	/dev/js0

################################################################################
# Fakespace Pinch Glove. Drives a Fakespace Pinch Glove device connected to a 
# serial port on this machine. This device has ten buttons-two hands and five
# fingers on each hand. Buttons 0-4 are fingers for the right hand-thumb first 
# and pinkie last- while buttons 5-9 are for the left hand-thumb first. The
# Button is ON when it is touching another finger. Therefore there cannot
# be just one Button ON. Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device

#vrpn_Button_PinchGlove	PinchGlove0		COM1		9600

################################################################################
# Adrienne Electronics Corporation PCI time code driver.  The PCI-VITC board
# for which this driver was developed reads in VITC time codes from an input
# signal.  This will drive one of these devices.
# Arguments:
# char name_of_this_device[]

#vrpn_TimeCode_Generator	TimeGen0

################################################################################
# 5DT glove (5 sensors plus optional tilt sensors).
# Drive a 5dt glove connected on a serial Port. This device uses
# optical fiber to get the finger position.
#
# See also vrpn_5DT16 (16-sensor serial) and vrpn_Analog_5dtUSB (5 or 14-sensor
# "Ultra" USB/wireless)
#
# 2 modes are driven: the first one let the driver get data from the glove
# when requested (we advise this mode). The second one makes the glove send
# data continuously. This mode may saturate the input buffer.
#
# The manual states that there will be 9 bytes per report, but one group
# has found that they get an extra one: 0x55 at the end of each report.
# So, you can choose whether to use 9 (the default) or 10 now.
# Gesture management is not implemented yet nor the mouse emulation mode
#
# The standard baud rate for the "wired" glove is 19200. For a "wireless"
# glove (which is send-only), even if directly connected, use baud rate
# 9600. The driver detects this and will adjust its behavior accordingly
# (forcing on continuous mode and 10-bytes-per-report, ignoring the settings
# you specify here).  If you aren't  sure what kind of glove you have, use the
# Glove Manager app in
# "5DT Data Glove Series: Full Package for Windows 95/98/NT/2000" downloaded from
# http://5dt.com/downloads.html and try to connect, it will tell you.
# Their Glove Manager worked for me on Linux 64-bit with WINE, and is probably the
# easiest way to find out this info if you don't know it. (Or, just try 9600 if
# 19200 doesn't work.)
#
# Reports the digit bend values in order, channels 1-5, in the range 0.0-1.0,
# and the tilt sensors in channels 6 and 7 in the range 0 to 180, if available
#
# arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device
#	int	mode_of_data_reporting (1 = on request, 2 = continuously)
#	int	ten_bytes_per_report (0 = no, use 9; 1 = yes)

#vrpn_5dt	glove_5dt	/dev/ttyS0	19200	1 0
#vrpn_5dt	glove_5dt	COM1	19200	1 0
#vrpn_5dt   glove_5dt_wireless /dev/ttyS1 9600 2 1

################################################################################
# NRL Serial Mouse. A device made by wiring buttons in parallel with the buttons
# on a serial mouse.  Both mousesystems or microsoft mouse protocols are 
# supported.  Note that the server code makes the connection at the standard
# 1200 baud.  The mouse can be plugged into any serial port -- this driver goes
# directly through the raw port and does not use the built-in mouse drivers.
# NOTE: The middle button on the 3button type is toggled by moving the mouse
# on a surface while not toggling the other two buttons, strange as this may
# seem.  The motion of the mouse is not reported, only the buttons.

#vrpn_Button_SerialMouse	Button0 /dev/ttyd1 mousesystems
#vrpn_Button_SerialMouse	Button0 COM1 mousesystems
#vrpn_Button_SerialMouse	Button0 COM1 3button  
# For a Linux box with a mouse on port 0
#vrpn_Button_SerialMouse	Button0 /dev/ttyS0 3button  
# For a mac with a Keyspan 4-port serial-to-USB converter
#vrpn_Button_SerialMouse	Button0 /dev/tty.USA49W3b12P1.1 3button

################################################################################
# NRL TNG3.  (Totally Neat Gadget) A device made by mindtel, available from
# pulsar.org.  Powered off the serial port control lines, the TNG3 has 8 digital
# and 8 analog inputs.  Analog resolution is 8 bits. Baud rate fixed internally
# at 19200.  
#       char    name_of_this_device[]
#       char    name_of_serial_device[]
#       int     number_of_buttons_to_read (i.e. 8 ==> 0,1,2,3,4,5,6,7)
#       int     number_of_analogs_to_read

#vrpn_Tng3      tng3name    /dev/ttyd2  4 0 
#vrpn_Tng3      tng3name    com1        8 8
#vrpn_Tng3      tng3name    com1        1 1

################################################################################
# Microsoft DirectX compatible force-feedback joystick (or non-force-feedback
# joystick).
#       char    name_of_this_device[]
#       int     number of times per second to read from the device
#       int     number of times per second to update force (0 for non-force device)

#vrpn_DirectXFFJoystick	Joystick0	60	200
#vrpn_DirectXFFJoystick	Joystick0	60	0


################################################################################
# Microsoft DirectX compatible rumble-pad (e.g. Wingman)
#       char    name_of_this_device[]

#vrpn_DirectXRumblePad		RumblePad0

################################################################################
# Microsoft XInput compatible controller (e.g. Xbox 360 gamepad)
#	char	name_of_this_device[]
#	int	userIndex (0 for "Player 1", 1 for "Player 2", etc.)

#vrpn_XInputGamepad		XInput0 0


################################################################################
# Manager for joysticks under windows using standard win32 calls.
# for force feedback support, see DirectX joystick above
#
# Arguments:
#	char	name_of_this_device[]
#	int	joystick Id
#           (1 for first joystick JOYSTICKID1 or 2 for second JOYSTICKID2 only)
# 	int  number of times per second to read from the device
# 	int  readmode : 0 = raw data;
#			1 = 0,1 normalized data;
#			2=-1,1 normalized data 
# 	int  percentage (0 to 100) of deadzone (used mode 1 and 2 only)

#vrpn_Joywin32 joyWin32 1 60 2 35

################################################################################
# Global Haptics GeoOrb serial-line device that contains a number of buttons,
# a thumbwheel, and a trackball.  For current devices, only 19200 baud works.
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device

#vrpn_GlobalHapticsOrb	Orb0	COM1	19200

################################################################################
# SensAble Technologies Phantom force-feedback device opened using the
# GHOST software developer's kit.  For Phantom Desktop systems, you don't
# need to have the user establish the reset position.  For the Premium models,
# you do.
# Arguments:
#	char	name_of_this_device[]
#	int	establish_reset_position	(0 or 1)
#	float	rate_to_send_tracker_reports
#	char	Name of the Phantom in the configuration control panel

#vrpn_Phantom	Phantom	0	60.0	Default PHANToM

##############################################################################
# Virtual Presence Joystick tracker device. (http://www.vrweb.com)
# Use this driver to read the button states,
# use Flock-of-Birds driver for the position/orientation state
#
# Arguments:
#  char  name_of_this_device[]
#  char  name_of_serial_device[]
#  int   baud_rate_of_serial_device

#vrpn_VPJoystick VPJoystick0 /dev/ttyS0 9600

################################################################################
# Advanced Realtime Tracking GmbH (http://www.ar-tracking.de) DTrack client 
#
# creates as many vrpn_Tracker as there are bodies or Flysticks, starting with the bodies
# creates 2 analogs per Flystick
# creates 8 buttons per Flystick
#
# NOTE: when using DTrack's older output format for Flystick data ('6df'), the numbering
#       of Flystick buttons differs from DTrack documentation (for compatibility with
#       older vrpn releases)
#
# Arguments:
#  char  name_of_this_device[]
#  int   udp_port                               (DTrack sends data to this UDP port)
#
# Optional arguments:
#  float time_to_reach_joy                      (in seconds; see below)
#  int   number_of_bodies, number_of_flysticks  (fixed numbers of bodies and Flysticks)
#  int   renumbered_ids[]                       (vrpn_Tracker IDs of bodies and Flysticks)
#  char  "3d"                                   (activates 3dof marker output if available;
#                                                always last argument if "-" is not present)
#  char  "-"                                    (activates tracing; always last argument)
#
# NOTE: time_to_reach_joy is the time needed to reach the maximum value (1.0 or -1.0) of the
#       joystick of older 'Flystick' devices when the corresponding button is pressed
#       (one of the last buttons amongst the 8); not necessary for newer 'Flystick2' devices
#       with its analog joystick
#
# NOTE: if fixed numbers of bodies and Flysticks should be used, both arguments
#       number_of_bodies and number_of_flysticks have to be set
#
# NOTE: renumbering of tracker IDs is only possible, if fixed numbers of bodies and
#       Flysticks are set; there has to be an argument present for each body/Flystick

#vrpn_Tracker_DTrack DTrack  5000
#vrpn_Tracker_DTrack DTrack  5000  -
#vrpn_Tracker_DTrack DTrack  5000  3d
#vrpn_Tracker_DTrack DTrack  5000  3d  -
#vrpn_Tracker_DTrack DTrack  5000  0.5
#vrpn_Tracker_DTrack DTrack  5000  0.5  2 2
#vrpn_Tracker_DTrack DTrack  5000  0.5  2 2  2 1 0 3
#vrpn_Tracker_DTrack DTrack  5000  0.5  2 2  2 1 0 3  3d  -

################################################################################
# National Instruments Analog Output server.  This will open the board whose
# name is specified, configure the number of channels specified, and set the
# polarity and maximum voltage range at which to drive the channels.
#
# XXX This server is deprecated, please use the vrpn_National_Instruments
# server listed below.
#
# Arguments:
#  char  vrpn_name_for_this_device[]
#  char  name_of_NI_board[]
#  int   number_of_channels
#  int   polarity : 0 = unipolar, 1 = bipolar
#  float min_voltage
#  float max_voltage

#vrpn_NI_Analog_Output	Analog_XY	DAQCard-6036E	2   0	-10.0 10.0
#vrpn_NI_Analog_Output	Analog_ZTweeze	DAQCard-6036E	2   0	-10.0 10.0
#vrpn_NI_Analog_Output	Analog_XYZ	PCI-6733	3   0	-10.0 10.0

################################################################################
# National Instruments A/D, D/A Analog and Analog Output server.  This will open
# the board whose name is specified, configure the number of channels specified,
# and set the polarity and maximum voltage range at which to read and
# drive the channels.
##
# Arguments:
#  char  vrpn_name_for_this_device[]
#  char  name_of_NationalInstruments_board[]
#  int   number_of_input_channels (can be zero)
#  float mininum_delay_between_Analog_Reports (zero for fastest)
#  int   input_polarity : 0 = unipolar, 1 = bipolar
#  int   input_mode : 0 = differential, 1 = ref single-end, 2 = non-ref SE
#  int   input_range : 5 = 5v, 10 = 10v, 20 = 20v
#  int   input_drive_ais : 0 = no, 1 = yes
#  int   input_gain
#  int   number_of_output_channels (can be zero)
#  int   output_polarity : 0 = unipolar, 1 = bipolar
#  float min_out_voltage (used to guard against overdriving devices)
#  float max_out_voltage (used to guard against overdriving devices)

# Input example
#vrpn_National_Instruments MCLXYZIN PCI-6052E 7 0 0 0 10 0 1 0 0 -10.0 10.0
# Output examples
#vrpn_National_Instruments MCLXYZOUT PCI-6733 0 0 0 0 10 0 1 3 0 0.0 10.0
#vrpn_National_Instruments Analog_XY DAQCard-6036E 0 0 0 0 10 0 1 2 1 -10.0 10.0

################################################################################
# Analog Poser. This is a poser that is intended to be used on top of
# an analog output (perhaps a National Instruments board), whose outputs
# directly drive the position of some actuated stage.  It could be used on top
# of any analog output device, in fact.  This device basically takes in poses
# and puts out analog outputs.
#   One analog channel is associated with each axis (X, Y, Z) and rotation about
# each axis (RX, RY, RZ). For each axis, the position (meters) is converted into
# a voltage; the orientation is mapped from a quaternion into Euler angles and
# each of the Euler angles is converted into a voltage (XXX Orientation is not yet
# implemented; the RX,RY, and RZ values must be specified but they are not used).
# XXX Velocity and orientation velocity are not yet supported.
#   Any axis can be disabled by setting the name of its associated device to the
# string "NULL".
#
# Arguments:
#	char  vrpn_name_for_this_device[]
#	int	send_tracker_reports
#	[six lines follow, one for X Y Z RX RY RZ, each with:
#		char	axis_name[]			(X Y Z RX RY RZ in that order)
#		char  vrpn_name_of_the_analog_output_to_use[]
#			(Preface with a * if it uses the same connection)
#		int	channel_of_analog_output_device (First channel is channel 0)
#		float offset
#		float	scale
#		float min_value of workspace
#		float max_value of workspace
#	]

#vrpn_Poser_Analog	Poser0	1
#X	*Analog_XY	0	0.0	1.0	-10	10
#Y	*Analog_XY	1	0.0	1.0	-10	10
#Z	*Analog_ZTweeze	0	0.0	1.0	-10	10
#RX	NULL	0	0.0	1.0	-10	10
#RY	NULL	0	0.0	1.0	-10	10
#RZ	NULL	0	0.0	1.0	-10	10

# Poser to drive Mad City Labs stage from an input value of
# 0 to 100 microns to an output (through a National Instruments
# D/A card) of 0-10 volts.
#vrpn_Poser_Analog	Poser0	1
#X	*MCLXYZOUT	0	0.0	0.1	0	100
#Y	*MCLXYZOUT	1	0.0	0.1	0	100
#Z	*MCLXYZOUT	2	0.0	0.1	0	100
#RX	NULL	0	0.0	1.0	-10	10
#RY	NULL	0	0.0	1.0	-10	10
#RZ	NULL	0	0.0	1.0	-10	10

################################################################################
# Nikon microscope connected to PC via serial port.  Currently only controls
# the focus of the microscope using an analogout and reads the focus position
# using an analog.
#
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]

#vrpn_nikon_controls	nikon	COM1

################################################################################
# Tektronix 4662 plotter.  Attaches to a serial port.  Acts as both a poser and
# a tracker.  Reports positions 4x per second plus when a move command completes.
# Multiple move commands issued before they complete will result in only the last
# one being executed.
#
# Arguments:
#	char	name_of_this_device[]
#	char	name_of_serial_device[]
#	int	baud_rate_of_serial_device

#vrpn_Tek4662	Tek4662	COM1	1200

###############################################################################
# keyboard and mouse button is a tracker with button system
# XXX These have been removed and replaced with vrpn_Mouse
# and vrpn_Keyboard.  Use the clutch option on vrpn_AnalogFly to
# replicate the mouse behavior.  The vrpn_Keyboard does not
# enable key mapping, just sends all of the keys' scancodes
# through.

################################################################################
# US Digital A2 Absolute Encoder Analog Input server.  This will open the COM 
# port specified, configure the number of channels specified, and report
# Absolute Encoder values in tenths of a degree from 0 to 3599.
#
# Arguments:
#	char	name_of_this_device[]
#       int     COM_port.  If 0, search for correct COM port.
#       int     number_of_channels
#	int	0 to report always, 1 to report on change only (optional, default=0)

#vrpn_Analog_USDigital_A2	Analog0 1	2

################################################################################
#      This is a driver for National Instruments DAQCard-
# DIO-24, a PCMCIA card, which provides 24-bit digital I/O.
#
# Arguments:
#	char	name_of_this_device[]
#       int     number_of_channls to read: 1-24 (optional.  default=24).

#vrpn_Button_NI_DIO24	Button0	1


##############################################################################
#PhaseSpace OWL server.  This device type is not compiled by default, since
#it uses a proprietary library.  However, you can get it to compile by 
#defining VRPN_INCLUDE_PHASESPACE and including the appropriate libraries
#and headers when compiling (See vrpn_Configure.h).   
#
#Arguments:
#       char	name_of_this_tracker[]   #Tracker0, Tracker1, ... etc       
#       char    location_of_OWL_device[] #typically localhost, or ip address
#       float   frame_rate               #between 0.0 and 480.0
#       int     read_till_most_recent    #0 or 1.  
#       int     slave_mode               #0 or 1.
#       [Additional lines specifying markers and rigid bodies]
#
#Specifying a frequency >0 will start streaming immediately at startup.
#To delay this, set the frequency to zero and adjust the update rate later.
#
#Specifying 1 for read_till_most_recent will cause the server to drop frames
#in order to get the most recent data on every run through the mainloop.
#This may be desirable for most VR applications and for slower machines.
#
#The format of the additional lines is as follows:
#
#Example:
#
#vrpn_Tracker_PhaseSpace Tracker0 localhost 480.0 1 0 
#<owl>   
#0 :     rbnew                            
#1 :     rb+     0      0       300     0     
#2 :     rb+     1      300     0       0     
#3 :     rb+     2      -300    0       0     
#4 :     rb+     3      0       76      -200  
#5 :     pt      4                      
#6 :     pt      5                      
#7 :     pt      6    #this is a comment                  
#8 :     pt      8                      
#9 :     pt      9                      
#</owl>
#
#
#
#       In regular expression syntax:
#       sensornumber : spectype led_id [xcoord  ycoord  zcoord]
#
#       The <owl> and </owl> tags indicate the start and end of the marker
#       and rigid body specifications.  Each line inside the tags correspond
#       to a sensor specified by the first number in the line.  Register 
#       callbacks as necessary.  The # character will cause the rest of
#       the line to be ignored.  Do not assign duplicate sensors.
#
#       There are 4 spectypes: "rbnew", "rb+", and "pt".
#
#       "pt" indicates a normal marker specification.
#       The number following it indicates the led id to assign to that sensor.
#       No further arguments are needed for the rest of the line. The vrpn 
#       server will return position data for that marker but no orientation 
#       data.  
#
#       "rbnew" indicates a new rigid body specification.  The lines following
#       it must be "rb+" lines, indicating the addition of markers to the
#       rigid body.  The "rb+" lines must have the x,y, and z coordinates of 
#       the rigid body marker specified after the led id.  The rigid body
#       itself is assigned the sensor of the "rbnew" line, and the markers
#       in the rigid body are given the sensor numbers of the "rb+" lines.
#       The rigid body specification continues until another "rbnew" line is 
#       encountered or until the </owl> tag.  If "pt" lines are mixed in, they
#       do not affect the rigid body. Rigid bodies will return an orientation
#       as well as positional data.  
#
#       Empty or invalid lines inside the <owl> and </owl> tags are also
#       ignored.
#
#       Care must be taken to AVOID specifying the same led id or sensor twice,
#       sensors and led ids should be unique.
#
#       The OWL server (not just the vrpn server) must still be configured to
#       track the specified markers.  Consult the PhaseSpace documentation to
#       see how.
#
#
#       Velocities and accelerations are not currently supported.
#
#       The frequency of streaming can be varied with set_update_rate()
#       in vrpn_Tracker_Remote. To stop streaming, set the update rate to
#       zero.
#               
#       For support, questions, comments, or bug reports please send emails 
#       to:  support@phasespace.com

#vrpn_Tracker_PhaseSpace Tracker0 localhost 480.0 1 0
#<owl>
#0 :     pt      0      #to sensor 0 assign led 0
#1 :     pt      1      #to sensor 1 assign led 1
#2 :     pt      2      #to sensor 2 assign led 2
#3 :     pt      3      #to sensor 3 assign led 3
#</owl>

################################################################################
# Generic Auxiliary Logger. This is a server that will listen for requests to
# produce additional log files and the name of the connection it should make the
# log files for.  It can only have one set of such logs open (can be more than
# one log but all for the same connection).  There are two arguments:
#	char	name_of_this_device[]
#	char	name_of_connection_to_log

#vrpn_Auxiliary_Logger_Server_Generic Logger0 localhost

################################################################################
# Imager Stream Buffer. This is a server that will listen for requests to
# produce additional log files and the name of the connection it should make the
# log files for.  It can only have one set of such logs open (can be more than
# one log but all for the same connection).  The "local" log files are with
# respect to the machine where this server is running, and the "remote" ones
# are with respect to the vrpn_Imager_Server it has connected to (which may
# be on yet a third machine compared to the client machine).
# There are two arguments:
#	char	name_of_this_device[]
#	char	name_of_imager_server_to_log

#vrpn_Imager_Stream_Buffer ImageStream0 TestImage@localhost

################################################################################
# X-Keys devices from P.I. Engineering.  There are four devices we have
# drivers for.  The only argument is the name of the device to open.  The Pro
# and Joystick models have not been tested.
#
# There is one argument:
#	char	name_of_this_device[]

#vrpn_Xkeys_Desktop xkeys0
#vrpn_Xkeys_Pro xkeys0
#vrpn_Xkeys_Joystick xkeys0
#vrpn_Xkeys_Jog_And_Shuttle xkeys0

################################################################################
# Space Navigator, Space Traveler, and Space Mouse devices from 3DConnexion.
# Not to be confused with the Magellan Space Mouse, for which there is
# a Magellan driver.
# The only argument is the name of the device to open.
#
# There is one argument:
#	char	name_of_this_device[]
#
# On Linux, make sure the HID and evdev drivers are running so that these
# devices will be recognized:
#  Start a separate Root shell:
#  cd .../vrpn/server_src/pc_linux
#  lsmod
#  modprobe evdev
#  modprobe hid
#  lsmod
#  (check that evdev and hid are running)
# On RedHat Linux, you need the have libusb1-devel installed and configure
#  the system for VRPN_USE_LOCAL_HIDAPI to get these to work.

#vrpn_3DConnexion_Navigator device0
#vrpn_3DConnexion_Navigator_for_Notebooks device0
#vrpn_3DConnexion_Traveler device0
#vrpn_3DConnexion_SpaceMouse device0
#vrpn_3DConnexion_SpaceExplorer device0
#vrpn_3DConnexion_SpaceBall5000 device0


################################################################################
# Open the mouse as an analog and button devices.  There is an implementation
# under Windows and another under Linux (using GPM).  There are two analog
# channels, reporting in the range [0..1] as the mouse moves across the screen.
# There are 3 button channels: left, middle, right.
#
# There is one argument:
#	char	name_of_this_device[]

#vrpn_Mouse	Mouse0

################################################################################
# Open the keyboard as a button device.  There is an implementation
# under Windows.  There are 256 buttons, and they are triggered according
# to the scan code that they represent.
#
# There is one argument:
#	char	name_of_this_device[]

#vrpn_Keyboard	Keyboard0

################################################################################
# WARNING : LINUX ONLY !
# Open the /dev/input devices and treat them as mouse events
# There is as many as available channel (kernel 2.6.38 : 10 channels)
#
# There is three argument:
#	char	name_of_this_device[] 
#	char	"name of the hardware device"
#	char	type of the device (must be one of "keyboard", "absolute" and "relative"
#	int	in case of keyboard : the total number of keys ; in case of absolute mouse : size of the window (ie. to normalize the result)
# The "name of the hardware device" is the Name entry of the device
# from /proc/bus/input/devices
# Due to hardware access through /dev/input/*, there is no notion of window.
# Thus, you must specify the window size. If '-1' is provided, then, this device
# only provide relative displacement of the channel
#
# Keyboard are standard keyboard (ie : the one on which you type elements
# Absolute are pointing devices such as touchpad : the position of the pointer is absolute regarding the size of the touch pad
# Relative are pointing devices such as mouse : the position of the pointer is a relative displacement regarding previous position
#
# BEWARE that you must have read access to the wanted device

#vrpn_DevInput           Input0          "AT Translated keyboard" keyboard 255

################################################################################
# MotionNode inertial tracking system.
#
# There are four arguments:
#	char	name_of_this_device[]
#	int	num_sensors
#	char	address
#	int	port

#vrpn_Tracker_MotionNode Tracker0 1 FIXME 1

################################################################################
# GPS device.
# This driver reads a GPS connected to the serial port at a given baud rate, and looks for
# the NMEA message providing long/lat/alt, which get copied into x/y/z
# respectively (of the position).  Should do a lot more (e.g., get velocity,
# bearing, perhaps convert to UTM).  But, for now, this is all it does.

# Open a GPS on MACOSX at 4800 baud

#vrpn_Tracker_GPS       Tracker0        /dev/tty.KeySerial1     4800
#vrpn_Tracker_GPS       Tracker0        /dev/tty.HOLUXGPSlim236-SPPslave-1      4800

#on windows
#vrpn_Tracker_GPS       Tracker0        COM1    4800

################################################################################
# Nintendo Wii Remote Controller
#	char	name_of_this_device[]
#	int	userIndex (1 for "Player 1", 2 for "Player 2", etc.)
#	int useMotionSensing
#	int useIR
#   int reorderButtons (set to make button ids somewhat more sensible)
#   char    bluetooth_address[] (optional, only supported on Linux - upper case,
#                                include colons)

#vrpn_WiiMote		WiiMote0 1 0 0 1

################################################################################
# Two-LED head tracking using Wii Remote Controller
#	char	name_of_this_device[]
#	char    name_of_vrpn_WiiMote_device[]
#	float   min_update_rate (default=60)
#	float   led_distance (default=0.205)
#
# Note: The WiiMote device must have useMotionSensing = 1 and useIR = 1

#vrpn_WiiMote		WiiMote0 1 1 1 1
#vrpn_Tracker_WiimoteHead  Tracker0 WiiMote0@localhost

################################################################################
# Novint Falcon attached to USB.
# Arguments:
#      char name_of_this_device[]
#      int  device index (starts at 0)
#      char name_of_grip (optional, default and only one supported now = "4-button")
#      char kinematic_model (optional, default and only one supported now ="stamper")
#      float damping_factor (optional, range 1.0-1000.0, default=10.0)
#vrpn_Tracker_NovintFalcon  Tracker0  0  4-button stamper 10.0

################################################################################
# Hillcrest Labs Freespace device
#	char	name_of_this_device[]
#	int	Index (0 for device 1, 1 for device 2, ...)
#	int	Send body frames (0 = no, 1 = yes)
#	int	Send user frames (0 = no, 1 = yes)

#vrpn_Freespace		FreeSpace0 0 1 1

################################################################################
# Dream Cheeky devices, of which only the USB Roll-Up Drum Kit is implemented.
#
# There is one argument:
#	char	name_of_this_device[]

#vrpn_Dream_Cheeky_USB_roll_up_drums drums0

################################################################################
# Trivisio Colibri device.  This is an inertial tracker that gives orientation 
# information, no position (the tracker reports (0, 0, 0) for position).
#
# Arguments:
#	char	name_of_this_device[]
#	int     number_of_sensors (Number of connected devices to connect to)
#	int     Hz (Update rate)
#	int	bufLen	(From the reference manual:
#			An short buffer (0) ensures minimal delay until the sensor
#			measurement is available at the risk of lost measurements. 
#			A long buffer guarantees that no data is dropped, at
#			the same time if data is not read fast enough there is a 
#			potential risk of a bufLen frequency before the measurement 
#			becomes available.)

#vrpn_Tracker_TrivisioColibri Colibri 1 60 0

################################################################################
# LUDL USBMAC6000 device.  This is a vrpn_Analog and a vrpn_Analog_Output device
# that lets you both move the stage by command and get a response when it has
# finished moving.
#
# Arguments:
#	char	name_of_this_device[]
#	int	Perform recentering on device (0 = no, 1 = yes)

#vrpn_LUDL_USBMAC6000 Analog0 1

################################################################################
# GameTrak tracker
# Reports 2 sensors with positions only
# This device uses another joystick device that needs to be configured (PC
# version of GameTrak shows up as a joystick device with 6 axes and a button)
# If the name of the joystick device starts with '*', it will take another
# one on this server, otherwise it will attempt a remote connection
#   char    name_of_this_device[]
#   char    name of the joystick device[]
#vrpn_Joylin  RawGametrak /dev/input/js1
#vrpn_Tracker_GameTrak GameTrak0 *RawGametrak


################################################################################
# PNI SpacePoint Fusion 3DOF rotation tracker
# Reports 1 sensor as quaternion
#   char    name_of_this_device[]

#vrpn_Tracker_SpacePoint SpacePoint0 

################################################################################
# 5DT DataGlove "Ultra" USB/USB Wireless support (based on HID)
#
# Reports 5 or 14 sensors' raw values as analogs 0-4 or 0-13, in range 0.0 - 1.0
# Note that your code will probably need to perform some scaling/calibration:
# see vrpn_Analog_5dtUSB.h for more info
#
# Four device types as shown in examples below: the server will connect to the
# first device available of that type.
#
# For serial (non-"Ultra") gloves, see vrpn_5dt and vrpn_5DT16
#
# Arguments:
#   char    name_of_this_device[]

#vrpn_Analog_5dtUSB_Glove5Right Glove5Right
#vrpn_Analog_5dtUSB_Glove5Left Glove5Left
#vrpn_Analog_5dtUSB_Glove14Right Glove14Right
#vrpn_Analog_5dtUSB_Glove14Left Glove14Left

################################################################################
# JsonNet devices
#
# Any device that send updates formatted as JSON messages, including
# Vrpn Widgets for Android
#
# see vrpn_Tracker_JsonNet.C for 
#
# Arguments:
#  char  name_of_this_device[]
#  int   udp_port                               (Device send JSON messages to this port)

#vrpn_Tracker_JsonNet Jsonnet  7777

################################################################################
# Razer Hydra (Sixense TrueMotion) tracker (HID-based driver)
#
# The left wand (the one with LB and LT on its "end" buttons - look from above)
# is sensor 0, and the right wand (with RB and RT on it) is sensor 1.
# The "front" of the base is the side opposite the cables: there's a small
# logo on it. You can have the base in any orientation you want, but the info
# that follows assumes you have the base sitting on a desk, with the front toward you.
# If you have the base in a different coordinate frame in the world, please make
# the appropriate mental transformations yourself. :)
#
# When starting the VRPN server, make sure that the left wand is somewhere to
# the left of the base, and the right wand somewhere right of the base -
# they do not need to be placed on the base or any more complicated homing/calibration
# procedure. This is for the hemisphere tracking: it needs to have an "initial state"
# that is roughly known, so it uses the sign of the X coordinate position.
#
# (If you can't do this for whatever reason, modification of the driver code for an
# alternate calibration procedure is possible.)
#
# If using the Hydra on Windows, the server will work with or without the official
# Razer Hydra drivers installed. If you are only using the device with VRPN, don't
# install the official drivers. However, if you do have them installed, make sure that
# the "Hydra Configurator" and the Hydra system tray icon are closed to avoid unexpected
# failure (their software can switch the device out of the mode that VRPN uses). You
# probably want to make sure that the tray icon doesn't auto-run on startup, since it
# can get even messier with Windows 7's "switch users" if you let it auto-run for each
# user.
#
# Works great on Linux (regardless of endianness) - no drivers needed, thanks to USB HID.
#
# The base coordinate system is right-handed with the axes:
#  X - out the right of the base
#  Y - out the front of the base
#  Z - down
#
# The wands are also right-handed, with the tracked point somewhere near
# the cable entry to the controller . When held with the joystick vertical,
# the axes are:
#  X - to the right
#  Y - out the front of the controller (trigger buttons)
#  Z - Up, along the joystick
#
#  Buttons are as follows, with the right controller's button channels starting
# at 8 instead of 0:
#  0 - "middle" button below joystick
#  1-4 - numbered buttons
#  5 - "bumper" button (above trigger)
#  6 - joystick button (if you push straight down on the joystick)
#
# Analog channels are as follows, with the right controller starting at 3
# instead of 0:
#  0 - joystick left/right: centered at 0, right is positive, in [-1, 1]
#  1 - joystick up/down: centered at 0, up is positive, in [-1, 1]
#  2 - analog trigger, in range 0 (not pressed) to 1 (fully pressed).
#
# Arguments:
#   char    name_of_this_device[]

#vrpn_Tracker_RazerHydra Tracker0

################################################################################
# Sensics zSight HMD with built-in tracker.  This is an inertial tracker that 
# gives orientation information, but no position (the tracker reports 
# (0, 0, 0) for position).
#
# Arguments:
#	char	name_of_this_device[]

#vrpn_Tracker_zSight zSight

################################################################################
# Arrington Research ViewPoint EyeTracker.
#
# The VRPN server connects to the eye tracker using the VPX_InterApp DLL.  
# Whatever other control software is being used to connect to the eye tracker
# (e.g. the ViewPoint software that comes with the tracker) to perform 
# calibration, etc. should link to the same copy of the DLL, so they can share 
# information.
#
#-------------------------------------------------------------------------------
# 
# Tracker:
# 
# The tracker has two sensors, as the ViewPoint can optionally have binocular
# tracking.  In the case of monocular tracking, only sensor 0 (EYE_A) will have 
# valid information.  Retrieving smoothed or raw tracking data is controlled by 
# the smoothedData parameter.
# 
# Position: The (x,y) gaze point in gaze space (smoothed or raw).
# 
# Rotation: The (x,y) gaze angle as a quaternion (smoothed or raw).
#               
# Velocity: The x- and y- components of the eye movement velocity in gaze space 
# (always smoothed).
# 
#-------------------------------------------------------------------------------
# 
# Analog:
# 
# There are a lot of additional data that can be retrieved from the tracker.
# These values are always calculated from the smoothed gaze point.  Currently, 
# the following are sent as analog values, but more can be added as needed.
# Please see the ViewPoint documentation regarding what other data are available.
# 
# Because each channel needs to be duplicated in the case of a binocular tracker, 
# the first n/2 values are for EYE_A, and the second n/2 values are for EYE_B.  
#          
# EYE_A:
# 
# Channel 0: The pupil aspect ratio, from 0.0 to 1.0.  Can be used to detect 
#            blinks when it falls below a given threshold.
# 
# Channel 1: The total velocity (magnitude of eye movement velocity).  Can be 
#            used to detect saccades.
# 
# Channel 2: The fixation seconds (length of time below the velocity criterion
#            used to detect saccades).  0 if saccade is occurring.
# 
# EYE_B:
# 
# Channels 3-5: See EYE_A.
#
#-------------------------------------------------------------------------------
#
# Arguments:
#  char  name_of_this_device[]
#  int   smoothedData

# vrpn_Tracker_ViewPoint ViewPoint 1

################################################################################
# vrpn_inertiamouse
# (Need a description of how to run this and an example commented-out line.)

###############################################################################
# $Header: /PDIvrpn.root/2.0.0/PDIVRPN/vrpn_G4.cfg 1     6/05/12 12:23p Ben $
#
# The command for a G4 requires the tracker name, the server name for the
# tracker, and on the next line, the file path to the .g4c configuration file:
#
# vrpn_Tracker_G4 G4 \
# C:\filepath\source_config_file.g4c
#
# The '\' at the end of the first line, after the server name, is optional and
# will be disregarded.  A '\' on a subsequent line means that further commands
# are to be input. The format is to have one command per line after the file
# path.  Each line that isn't the final line must end in a '\'.
#	The final line should not have a '\' on the end.
#
# Supported G4 Configuration Commands:
#	'B'		Set/Reset Boresight
#	'X'		Set/Reset Position Filter
#	'Y'		Set/Reset Attitude Filter
#	'T'		Set/Reset G4 Translation Frame of Reference
#	'R'		Set/Reset G4 Rotation Frame of Reference
#	'I'		Set/Reset Sensor Increment/Auto-Increment
#	'N'		Set/Reset Sensor Tip Offset
#
# Command Syntax:
#------------------------------------------------------------------------------
# 'B' Boresight Command 'B':
#
#		Syntax:	Baction,hub,sensor,[x,y,z,w]
#
#		Arguments:
#			action: 
#					1 = Boresight
#					2 = Unboresight
#
#			hub:		HubID. (0-based.) To apply Boresight/Unboresight to all hubs & sensors, set to * or -1.
#			sensor:		Sensor Num. (0-based.) To apply Boresight/Unboresight to all sensors on a hub, set to *
#								Note: If hub is *, set sensor to * also.
#			[x,y,z,w]:	Optional Quaternion XYZW Boresight Reference Orientation.  
#						All 4 values must be set.
#						N/A for action=2
#
#		Examples:
#			B2,-1,-1	Un-Boresights all sensors on all hubs
#			B1,-1,-1	Boresights all sensors on all hubs
#			B1,1,-1,
#------------------------------------------------------------------------------
# 'X' Position Filter Command 'X':
# 'Y' Attitude Filter Command 'Y':
#
#		Syntax:	Xaction,hub,flevel,[F,FLow,FHigh,Factor]
#				Yaction,hub,flevel,[F,FLow,FHigh,Factor]
#
#		Arguments:
#			action: 
#					1 = Set
#					2 = Reset
#
#			hub:		HubID. (0-based.) To apply filter to all hubs, set to *
#			flevel:		Filter Level
#						0=None
#						1=Light
#						2=Medium
#						3=Heavy
#						4=Custom
#			[F,FLow,FHigh,Factor]:	Optional Floating-point Parameters used only if flevel=Custom.
#									If custom parameters are used, it is assumed that all four custom parameters are present.
#									See Tracker User manual for meaning of Custom Filter Values.
#		Examples:
#			X*,1					Sets Position Filtering to LIGHT on all hubs
#			Y2,0					Sets Attitude Filtering to NONE on hub 2
#			X1,4,0.2,0.2,0.8,0.95	Sets Custom Filter on hub 1
#------------------------------------------------------------------------------
#	'T'	Translation Frame of Reference Command 'T':
#
#		Syntax:	Taction,x,y,z
#
#		Arguments:
#			action: 
#					1 = Set
#					2 = Reset
#
#			x,y,z:	Position Offset, measured in Meters
#					All arguments must be present
#
#		Examples:
#			T1,1.0,1.5,1.0			Sets Translation Frame of Reference to (1.0, 1.5, 1.0) meters
#			Y2						Resets Translation Frame of Reference
#
#		Note: Frame of Reference commands apply to all G4 output.  
#------------------------------------------------------------------------------
#	'R'	Rotation Frame of Reference Command 'R':
#
#		Syntax:	Raction,hub,x,y,z,w
#
#		Arguments:
#			action: 
#					1 = Set
#					2 = Reset
#
#			x,y,z,w:	Rotation Quaternion XYZW
#						All arguments must be present
#
#		Examples:
#			R1,0,0,0.707107,0.707107 Sets Rotation Frame of Reference 
#			R2						 Resets Rotation Frame of Reference
#
#		Note: Frame of Reference commands apply to all G4 output.  
#------------------------------------------------------------------------------
#	'I'	Increment/AutoIncrement Command 'I':
#
#		Syntax:	Iaction,hub,sensor,fPosIncr,fOriIncr
#
#		Arguments:
#			action: 
#					1 = Set
#					2 = Reset
#
#			hub:		HubID. (0-based.) To apply command to all hubs & sensors, set to * or -1
#			sensor:		Sensor Num. (0-based.) To apply command to all sensors on a hub, set to * or -1
#								Note: If hub is *, set sensor to * also.
#
#			posIncr:	Position Threshold, Meters
#						 0 Disables 
#						-1 Enables Auto-Increment
#
#			oriIncr:	Orientation Threshold, DEGREES
#						 0 Disables 
#						-1 Enables Auto-Increment
#
#		Examples:
#			I1,*,*,0.01,5.0	 For all hubs/sensors, sets position increment to 10 cm, 
#													    rotation increment to 5 degrees 
#			I1,*,*,-1,-1	 For all hubs/sensors, enables position and rotation auto-increment
#			I2,0,2			 For hub0, sensor2, resets/disables increment
#
#------------------------------------------------------------------------------
#	'N'	Tip Offset Command 'N':
#
#		Syntax:	Iaction,hub,sensor,x,y,z
#
#		Arguments:
#			action: 
#					1 = Set
#					2 = Reset
#
#			hub:		HubID. (0-based.) To apply command to all hubs & sensors, set to * or -1
#			sensor:		Sensor Num. (0-based.) To apply command to all sensors on a hub, set to * or -1
#								Note: If hub is *, set sensor to * also.
#
#			x,y,z:	Position Offset, measured in Meters
#					All arguments must be present
#
#		Examples:
#			N1,0,0,0.005,0.001,0.001	For hub0,sensor0, sets tip offset to (5,1,1)cm
#			N2,*,*						For all hubs/sensors, resets tip offset
#
#------------------------------------------------------------------------------
# Example command for setup of a G4

# vrpn_Tracker_G4	G4\
# C:\Program Files (x86)\Polhemus\G4\G4 Files\mysourceconfig.g4c \
# B1,-1,-1\
# X1,*,1\
# Y1,*,4,0.2,0.2,0.8,0.95\
# T1, 10.0, 10.0, 10.0, 10.0\
# R1,0,0,0,1\
# I1,*,*,0.01,5.0\
# N1,0,*,0.005,0.002,0.001\
# N2,*,*

###############################################################################
# The command for a FastrakPDI requires the tracker name, and the server name for the tracker:
#
# vrpn_Tracker_FastrakPDI Fastrak\       <-valid
# vrpn_Tracker_FastrakPDI Highpoint\     <-valid
#
# The '\' at the end of the first line, after the server name, is optional and will be disregarded.
#   a '\' on a subsequent line means that further commands are to be input. The format is to have
#   one command per line.  Each line that isn't the final line must end in a '\'.  The final line should not
#   have a '\' on the end.
#
# Supported Fastrak Configuration Commands:
#   All commands are exposed, except C and c for continuous pno which would conflict with VRPN directly.
#   Take note that O<> should be avoided, though it will be sent to the tracker.  VRPN clients expect position
#   x,y,z and quaternion q,r,s,t by default, so changing the frame structure could result in an overflow.
#   The format commands ('F' for ASCII, f for binary) are especially useful since the tracker can mark
#   syntax errors in ASCII mode.  The tracker must be in binary mode for VRPN to gather data, so if you issue
#   an F command at some point in this file (to troubleshoot syntax errors), be sure to issue an f<>
#   command later.  Not all fastrak commands have a response: boresight, for example.  You can confirm
#   such settings by requesting a single frame in ASCII mode with the command P (note, P requires no <>).
#   Read the fastrak manual for a full list of commands.
#
# Command Syntax:
#   Many commands, much like P (gather single pno frame), require no carriage return on the end.  Carriage
#   returns are represented by '<>'.  Control commands, noted as ^$ (where $ is any capitol letter) in the
#   manual require a '^' followed by the capital letter for the command.  Syntax is precisely as given in
#   examples in the fastrak manual.  Note that all commands are case sensitive.
#    Examples:
#     F              <-Sets the response frame format to ASCII
#     f              <-Sets the response frame format to binary
#     b*<>           <-Removes the boresight setting for all sensors
#     B1<>           <-Sets the boresight to 0,0,0 as a default or whatever G<> was set to
#     G1,0,0,0<>     <-Sets the boresight reference angles of station 1 to 0,0,0
#     ^Y             <-Sends a reset command to the tracker, note that VRPN defaults for pno will be loaded on
#                       reconnect
#
#------------------------------------------------------------------------------
# The following example config sets the tracker to ASCII responses (F), sets the boresight reference on sensor
# one to 0,0,0, (G1,0,0,0<>) writes this reference to the system with B1<>, confirms the change by collecting a 
# single pno with P, removes the boresight setting (^b1<>), collects a second single pno to confirm this removal
# (P) and finally returns to binary mode before passing control to VRPN (F1<>).  The trackers name is TrackerJoe.

# vrpn_Tracker_FastrakPDI	TrackerJoe\
# F\
# G1,0,0,0<>\
# B1<>\
# P\
# b1<>\
# P\
# f

#------------------------------------------------------------------------------
# The default config is below.

# vrpn_Tracker_FastrakPDI Blueberry

###############################################################################
# The command for a LibertyPDI or PatriotPDI requires the tracker name, and the server name for the tracker:
#
# vrpn_Tracker_LibertyPDI Liberty\       <-valid
# vrpn_Tracker_LibertyPDI Patriot\       <-valid
# vrpn_Tracker_LibertyPDI BriansTracker\ <-valid
# vrpn_Tracker_PatriotPDI Patriot\       <-Not valid.  Use vrpn_Tracker_LibertyPDI for patriot and liberty 
#
# The '\' at the end of the first line, after the server name, is optional and will be disregarded.
#   a '\' on a subsequent line means that further commands are to be input. The format is to have
#   one command per line.  Each line that isn't the final line must end in a '\'.  The final line should not
#   have a '\' on the end.
#
# Supported Liberty/Patriot Configuration Commands:
#   All commands are accepted, except C<> for continuous pno output which would conflict with VRPN directly.
#   Take note that O<> should be avoided, though it will be sent to the tracker.  VRPN clients expect position
#   x,y,z and quaternion q,r,s,t by default, so changing the frame structure could result in an overflow.
#   The format command (F0<> for ASCII, F1<> for binary) is especially useful since the tracker can mark
#   syntax errors in ASCII mode.  The tracker must be in binary mode for VRPN to gather data, so if you issue
#   an F0<> command at the beginning of this file (to troubleshoot syntax errors), be sure to issue an F1<>
#   command later.  Not all liberty/patriot commands have a response: boresight, for example.  You can confirm
#   these settings by requesting a single frame in ASCII mode with the command P (note, P requires no <>).
#   Read the patriot or liberty manual for a full list of commands.
#
# Command Syntax:
#   Every command, except P (gather single pno frame), requires a carriage return on the end.  Carriage
#   returns are represented by '<>'.  Control commands, noted as ^X (where X is any capitol letter) in the
#   manual require a '^' followed by the capital letter for the command.  Syntax is precisely as given in
#   examples in the patriot/liberty manuals.
#    Examples:
#     ^V<>            <-This command sends a 'whoami' request to the tracker.  Requires ascii mode for response
#     F<>             <-Queries format mode of tracker (binary or ascii)
#     F0<>            <-Sets the response frame format to ASCII
#     F1<>            <-Sets the response frame format to binary
#     ^B*<>           <-Removes the boresight setting for all sensors
#     B1<>            <-Queries the boresight setting for sensor one
#     B1,0,0,0,0      <-Sets the boresight to 0,0,0 without a reset for sensor one
#     ^Y<>            <-Sends a reset command to the tracker, note that VRPN defaults for pno will be loaded on
#                       reconnect
#
#------------------------------------------------------------------------------
# The following example config sets the tracker to ASCII responses (F0<>), sends the tracker a whoami (^V<>),
# sets the boresight on sensor one (B1,0,0,0,0<>) to an arbitrary value, confirms the boresight setting with
# P to collect a single pno, removes the boresight setting (^B1<>), collects a second single pno to confirm
# (P), enters an invalid command to demonstrate the advantage of ASCII mode (^ZX<>) and finally, most
# importantly, returns to binary mode before passing control to VRPN (F1<>).  The trackers name is TrackerJohn.

# vrpn_Tracker_LibertyPDI	TrackerJohn\
# F0<>\
# ^V<>\
# B1,0,0,0,0<>\
# P\
# ^B1<>\
# P\
# ^ZX<>\
# F1<>

#-----------------------------------------------------------------------------
# Finally the default config is below.
##############################################################################

# vrpn_Tracker_LibertyPDI Strawberry\
# F0<>\
# ^V<>\
# F1<>

